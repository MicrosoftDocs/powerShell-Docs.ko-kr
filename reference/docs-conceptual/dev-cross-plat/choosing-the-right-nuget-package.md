---
title: .NET 프로젝트에 적합한 PowerShell NuGet 패키지 선택
description: 각 PowerShell 릴리스로 게시된 실행 파일 패키지와 함께 PowerShell 팀은 NuGet에서 사용할 수 있는 여러 패키지도 유지 관리합니다. 해당 패키지는 .NET의 API 플랫폼으로 PowerShell을 대상으로 지정할 수 있습니다.
ms.date: 06/25/2020
ms.custom: rjmholt
ms.openlocfilehash: 39369ed872faa76ad2c41d813da5e0a98cf1c078
ms.sourcegitcommit: d0461273abb6db099c5e784ef00f57fd551be4a6
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/01/2020
ms.locfileid: "85795322"
---
# <a name="choosing-the-right-powershell-nuget-package-for-your-net-project"></a><span data-ttu-id="6bb56-104">.NET 프로젝트에 적합한 PowerShell NuGet 패키지 선택</span><span class="sxs-lookup"><span data-stu-id="6bb56-104">Choosing the right PowerShell NuGet package for your .NET project</span></span>

<span data-ttu-id="6bb56-105">각 PowerShell 릴리스로 게시된 `pwsh` 실행 파일 패키지와 함께 PowerShell 팀은 [NuGet][]에서 사용할 수 있는 여러 패키지도 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-105">Alongside the `pwsh` executable packages published with each PowerShell release, the PowerShell team also maintains several packages available on [NuGet][].</span></span> <span data-ttu-id="6bb56-106">해당 패키지는 .NET의 API 플랫폼으로 PowerShell을 대상으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-106">These packages allow targeting PowerShell as an API platform in .NET.</span></span>

<span data-ttu-id="6bb56-107">API를 제공하고 자체(이진 모듈)을 구현하는 .NET 라이브러리를 로드해야 하는 .NET 애플리케이션으로, PowerShell은 NuGet 패키지 형식으로 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-107">As a .NET application that provides APIs and expects to load .NET libraries implementing its own (binary modules), it's essential that PowerShell be available in the form of a NuGet package.</span></span>

<span data-ttu-id="6bb56-108">현재 PowerShell API 노출 영역의 일부 표시를 제공하는 여러 NuGet 패키지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-108">Currently there are several NuGet packages that provide some representation of the PowerShell API surface area.</span></span> <span data-ttu-id="6bb56-109">특정 프로젝트에서 사용할 패키지가 무엇인지 항상 분명한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-109">Which package to use with a particular project hasn't always been made clear.</span></span> <span data-ttu-id="6bb56-110">이 문서에서는 PowerShell 대상 .NET 프로젝트의 몇 가지 일반적인 시나리오와 함께 PowerShell 기반 .NET 프로젝트의 대상으로 지정할 적합한 NuGet 패키지를 선택하는 방법을 중점적으로 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-110">This article sheds some light on a few common scenarios for PowerShell-targeting .NET projects and how to choose the right NuGet package to target for your PowerShell-oriented .NET project.</span></span>

## <a name="hosting-vs-referencing"></a><span data-ttu-id="6bb56-111">호스팅 및 참조 비교</span><span class="sxs-lookup"><span data-stu-id="6bb56-111">Hosting vs referencing</span></span>

<span data-ttu-id="6bb56-112">일부 .NET 프로젝트는 기존 PowerShell 런타임에 로드되는 코드(예: `pwsh`, `powershell.exe`, PowerShell 통합 콘솔 또는 ISE)를 작성하려고 하지만 다른 프로젝트는 자체 애플리케이션에서 PowerShell을 실행하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-112">Some .NET projects seek to write code to be loaded into a pre-existing PowerShell runtime (such as `pwsh`, `powershell.exe`, the PowerShell Integrated Console or the ISE), while others want to run PowerShell in their own applications.</span></span>

- <span data-ttu-id="6bb56-113">**참조**는 프로젝트(일반적으로 모듈)가 PowerShell로 로드되어야 하는 경우에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-113">**Referencing** is for when a project, usually a module, is intended to be loaded into PowerShell.</span></span>
  <span data-ttu-id="6bb56-114">프로젝트와 상호 작용하려면 PowerShell이 제공하는 API에 대해 프로젝트를 컴파일해야 하지만, PowerShell 구현은 프로젝트를 로드하는 PowerShell 프로세스에서 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-114">It must be compiled against the APIs that PowerShell provides in order to interact with it, but the PowerShell implementation is supplied by the PowerShell process loading it in.</span></span> <span data-ttu-id="6bb56-115">참조를 위해 프로젝트는 [참조 어셈블리][] 또는 실제 런타임 어셈블리를 컴파일 대상으로 사용할 수 있지만, 관련 어셈블리를 빌드와 함께 게시하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-115">For referencing, a project can use [reference assemblies][] or the actual runtime assemblies as a compilation target, but must ensure that it does not publish any of these with its build.</span></span>
- <span data-ttu-id="6bb56-116">프로젝트는 일반적으로 PowerShell을 실행해야 하는 독립 실행형 애플리케이션이기 때문에 **호스팅**은 프로젝트에 자체 PowerShell 구현이 필요한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-116">**Hosting** is when a project needs its own implementation of PowerShell, usually because it is a standalone application that needs to run PowerShell.</span></span> <span data-ttu-id="6bb56-117">이 경우 순수 참조 어셈블리를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-117">In this case, pure reference assemblies cannot be used.</span></span> <span data-ttu-id="6bb56-118">대신, 구체적인 PowerShell 구현에 종속되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-118">Instead, a concrete PowerShell implementation must be depended upon.</span></span> <span data-ttu-id="6bb56-119">구체적인 PowerShell 구현을 사용해야 하므로 호스팅을 위해 특정 버전의 PowerShell을 선택해야 하며, 단일 호스트 애플리케이션은 PowerShell 버전을 다중 대상으로 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-119">Because a concrete PowerShell implementation must be used, a specific version of PowerShell must be chosen for hosting; a single host application cannot multi-target PowerShell versions.</span></span>

### <a name="publishing-projects-that-target-powershell-as-a-reference"></a><span data-ttu-id="6bb56-120">PowerShell을 대상으로 하는 프로젝트를 참조로 게시</span><span class="sxs-lookup"><span data-stu-id="6bb56-120">Publishing projects that target PowerShell as a reference</span></span>

> [!NOTE]
> <span data-ttu-id="6bb56-121">이 문서에서는 `dotnet publish` 실행을 나타내는 **게시**라는 용어를 사용하며, 해당 작업은 특정 런타임에 배포할 수 있는 모든 관련 종속성과 함께 .NET 라이브러리를 디렉터리에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-121">We use the term **publish** in this article to refer to running `dotnet publish`, which places a .NET library into a directory with all of its dependencies, ready for deployment to a particular runtime.</span></span>

<span data-ttu-id="6bb56-122">컴파일 참조 대상으로 사용되는 프로젝트 종속성 게시를 방지하기 위해 [PrivateAssets 특성][]을 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-122">In order to prevent publishing project dependencies that are just being used as compilation reference targets, it is recommended to set the [PrivateAssets attribute][]:</span></span>

```xml
<PackageReference Include="PowerShellStandard.Library" Version="5.1.0.0" PrivateAssets="all" />
```

<span data-ttu-id="6bb56-123">해당 작업을 기억하지 못하고 참조 어셈블리를 대상으로 사용하면 실제 구현 대신 참조 어셈블리의 기본 구현을 사용하는 것에 관련된 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-123">If you forget to do this and use a reference assembly as your target, you may see issues related to using the reference assembly's default implementation instead of the actual implementation.</span></span> <span data-ttu-id="6bb56-124">참조 어셈블리는 종종 단순히 `null`을 반환하여 구현 API를 모방하므로 해당 문제는 `NullReferenceException` 형식으로 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-124">This may take the form of a `NullReferenceException`, since reference assemblies often mock the implementation API by simply returning `null`.</span></span>

## <a name="key-kinds-of-powershell-targeting-net-projects"></a><span data-ttu-id="6bb56-125">PowerShell 대상 .NET 프로젝트의 키 종류</span><span class="sxs-lookup"><span data-stu-id="6bb56-125">Key kinds of PowerShell-targeting .NET projects</span></span>

<span data-ttu-id="6bb56-126">모든 .NET 라이브러리나 애플리케이션은 PowerShell을 포함할 수 있지만 PowerShell API를 사용하는 몇 가지 일반적인 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-126">While any .NET library or application can embed PowerShell, there are some common scenarios that use PowerShell APIs:</span></span>

- <span data-ttu-id="6bb56-127">**PowerShell 이진 모듈 구현**</span><span class="sxs-lookup"><span data-stu-id="6bb56-127">**Implementing a PowerShell binary module**</span></span>

  <span data-ttu-id="6bb56-128">PowerShell 이진 모듈은 각각 cmdlet 또는 공급자를 공개하기 위해 [PSCmdlet][] 또는 [CmdletProvider][] 형식과 같은 PowerShell API를 구현해야 하는 PowerShell에서 로드하는 .NET 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-128">PowerShell binary modules are .NET libraries loaded by PowerShell that must implement PowerShell APIs like the [PSCmdlet][] or [CmdletProvider][] types in order to expose cmdlets or providers respectively.</span></span> <span data-ttu-id="6bb56-129">모듈은 로드되기 때문에 빌드에 게시하지 않고 PowerShell에 대한 참조에 대해 컴파일하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-129">Because they are loaded in, modules seek to compile against references to PowerShell without publishing it in their build.</span></span> <span data-ttu-id="6bb56-130">또한 일반적으로 모듈은 이상적으로 디스크 공간, 복잡성 또는 반복 구현의 오버헤드를 최소화하여 여러 PowerShell 버전 및 플랫폼을 지원하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-130">It's also common for modules to want to support multiple PowerShell versions and platforms, ideally with a minimum of overhead of disk space, complexity, or repeated implementation.</span></span> <span data-ttu-id="6bb56-131">모듈에 관한 자세한 내용은 [about_Modules][]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6bb56-131">See [about_Modules][] for more information about modules.</span></span>

- <span data-ttu-id="6bb56-132">**PowerShell 호스트 구현**</span><span class="sxs-lookup"><span data-stu-id="6bb56-132">**Implementing a PowerShell Host**</span></span>

  <span data-ttu-id="6bb56-133">PowerShell 호스트는 PowerShell 런타임의 상호 작용 계층을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-133">A PowerShell Host provides an interaction layer for the PowerShell runtime.</span></span> <span data-ttu-id="6bb56-134">해당 호스트는 [PSHost][]가 PowerShell에 대한 새로운 사용자 인터페이스로 구현되는 특정 ‘호스팅’ 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-134">It is a specific form of _hosting_, where a [PSHost][] is implemented as a new user interface to PowerShell.</span></span> <span data-ttu-id="6bb56-135">예를 들어 PowerShell ConsoleHost는 PowerShell 실행 파일의 터미널 사용자 인터페이스를 제공하는 반면, PowerShell 편집기 서비스 호스트와 ISE 호스트는 둘 다 PowerShell에 관련된 편집기 통합형 부분 그래픽 사용자 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-135">For example, the PowerShell ConsoleHost provides a terminal user interface for PowerShell executables, while the PowerShell Editor Services Host and the ISE Host both provide an editor-integrated partially graphical user interface around PowerShell.</span></span> <span data-ttu-id="6bb56-136">호스트를 기존 PowerShell 프로세스에 로드할 수 있지만 호스트 구현이 PowerShell 엔진을 재배포하는 독립 실행형 PowerShell 구현으로 작동하는 것이 훨씬 더 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-136">While it's possible to load a host onto an existing PowerShell process, it's much more common for a host implementation to act as a standalone PowerShell implementation that redistributes the PowerShell engine.</span></span>

- <span data-ttu-id="6bb56-137">**다른 .NET 애플리케이션에서 PowerShell 호출**</span><span class="sxs-lookup"><span data-stu-id="6bb56-137">**Calling into PowerShell from another .NET application**</span></span>

  <span data-ttu-id="6bb56-138">모든 애플리케이션과 마찬가지로 PowerShell은 하위 프로세스로 호출하여 워크로드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-138">As with any application, PowerShell can be called as a subprocess to run workloads.</span></span> <span data-ttu-id="6bb56-139">그러나 .NET 애플리케이션은 PowerShell In Process를 호출하여 호출 애플리케이션 내에서 사용할 전체 .NET 개체를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-139">However, as a .NET application, it's also possible to invoke PowerShell in-process to get back full .NET objects for use within the calling application.</span></span> <span data-ttu-id="6bb56-140">이는 애플리케이션이 내부 사용을 위해 자체 PowerShell 구현을 저장하는 더 일반적인 ‘호스팅’ 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-140">This is a more general form of _hosting_, where the application holds its own PowerShell implementation for internal use.</span></span> <span data-ttu-id="6bb56-141">해당 호스트의 예로는 머신 상태를 관리하기 위해 PowerShell을 실행하는 서비스 또는 디먼이나 클라우드 배포 관리 같은 작업을 수행하기 위해 요청 시 PowerShell을 실행하는 웹 애플리케이션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-141">Examples of this might be a service or daemon running PowerShell to manage machine state or a web application that runs PowerShell on request to do something like manage cloud deployments.</span></span>

- <span data-ttu-id="6bb56-142">**.NET의 PowerShell 모듈 단위 테스트**</span><span class="sxs-lookup"><span data-stu-id="6bb56-142">**Unit testing PowerShell modules from .NET**</span></span>

  <span data-ttu-id="6bb56-143">PowerShell에 기능을 공개하도록 디자인된 모듈 및 기타 라이브러리는 기본적으로 PowerShell에서 테스트해야 하지만([Pester][] 권장) .NET에서 PowerShell 모듈용으로 작성된 API를 단위 테스트해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-143">While modules and other libraries designed to expose functionality to PowerShell should be primarily tested from PowerShell (we recommend [Pester][]), sometimes it's necessary to unit test APIs written for a PowerShell module from .NET.</span></span> <span data-ttu-id="6bb56-144">해당 상황에는 다양한 PowerShell 버전을 대상으로 지정하려는 모듈 코드가 포함되지만 테스트 시에는 구체적인 특정 구현에서 해당 코드를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-144">This situation involves the module code trying to target a number of PowerShell versions, while testing should run it on specific, concrete implementations.</span></span>

## <a name="powershell-nuget-packages-at-a-glance"></a><span data-ttu-id="6bb56-145">PowerShell NuGet 패키지 한눈에 보기</span><span class="sxs-lookup"><span data-stu-id="6bb56-145">PowerShell NuGet packages at a glance</span></span>

<span data-ttu-id="6bb56-146">이 문서에서는 PowerShell API를 공개하는 다음 NuGet 패키지를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-146">In this article, we'll cover the following NuGet packages that expose PowerShell APIs:</span></span>

- <span data-ttu-id="6bb56-147">[PowerShellStandard.Library][] - 여러 PowerShell 런타임에서 로드할 수 있는 단일 어셈블리를 빌드하는 데 사용되는 참조 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-147">[PowerShellStandard.Library][], a reference assembly that enables building a single assembly that can be loaded by multiple PowerShell runtimes.</span></span>
- <span data-ttu-id="6bb56-148">[Microsoft.PowerShell.SDK][] - 전체 PowerShell SDK를 대상으로 지정하고 다시 호스트하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-148">[Microsoft.PowerShell.SDK][], the way to target and rehost the whole PowerShell SDK</span></span>
- <span data-ttu-id="6bb56-149">[System.Management.Automation][] 패키지 - 최소한의 호스티드 구현 및 버전별 대상 지정 시나리오에 유용할 수 있는 핵심 PowerShell 런타임 및 엔진 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-149">The [System.Management.Automation][] package, the core PowerShell runtime and engine implementation, that can be useful in minimal hosted implementations and for version-specific targeting scenarios.</span></span>
- <span data-ttu-id="6bb56-150">**Windows PowerShell 참조 어셈블리** - Windows PowerShell(PowerShell 버전 5.1 이하)을 대상으로 지정하고 효과적으로 다시 호스트하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-150">The **Windows PowerShell reference assemblies**, the way to target and effectively rehost Windows PowerShell (PowerShell versions 5.1 and below).</span></span>

> [!NOTE]
> <span data-ttu-id="6bb56-151">[PowerShell NuGet][] 패키지는 .NET 라이브러리 패키지가 아니지만 대신 PowerShell dotnet 전역 도구 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-151">The [PowerShell NuGet][] package is not a .NET library package at all, but instead provides the PowerShell dotnet global tool implementation.</span></span> <span data-ttu-id="6bb56-152">해당 패키지는 실행 파일만 제공하므로 프로젝트에서 사용하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-152">This should not be used by any projects, since it only provides an executable.</span></span>

## <a name="powershellstandardlibrary"></a><span data-ttu-id="6bb56-153">PowerShellStandard.Library</span><span class="sxs-lookup"><span data-stu-id="6bb56-153">PowerShellStandard.Library</span></span>

<span data-ttu-id="6bb56-154">PowerShell Standard 라이브러리는 PowerShell 버전 7, 6 및 5.1의 API 교집합을 캡처하는 참조 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-154">The PowerShell Standard library is a reference assembly that captures the intersection of the APIs of PowerShell versions 7, 6 and 5.1.</span></span> <span data-ttu-id="6bb56-155">.NET 코드를 컴파일할 컴파일 시간이 검사된 API 표면을 제공하므로 .NET 프로젝트가 존재하지 않는 API를 호출할 위험 없이 PowerShell 버전 7, 6 및 5.1을 대상으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-155">This provides a compile-time-checked API surface to compile .NET code against, allowing .NET projects to target PowerShell versions 7, 6 and 5.1 without risking calling an API that won't be there.</span></span>

<span data-ttu-id="6bb56-156">PowerShell Standard는 PowerShell 모듈을 작성하거나 PowerShell 프로세스로 로드한 후에만 실행되는 다른 코드를 작성하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-156">PowerShell Standard is intended for writing PowerShell modules, or other code only intended to be run after loading it into a PowerShell process.</span></span> <span data-ttu-id="6bb56-157">PowerShell Standard는 참조 어셈블리이기 때문에 구현 자체를 포함하지 않으므로 독립 실행형 애플리케이션을 위한 기능을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-157">Because it is a reference assembly, PowerShell Standard contains no implementation itself, so provides no functionality for standalone applications.</span></span>

### <a name="using-powershell-standard-with-different-net-runtimes"></a><span data-ttu-id="6bb56-158">다른 .NET 런타임에서 PowerShell Standard 사용</span><span class="sxs-lookup"><span data-stu-id="6bb56-158">Using PowerShell Standard with different .NET runtimes</span></span>

<span data-ttu-id="6bb56-159">PowerShell Standard는 .NET Framework 및 .NET Core에서 공유하는 일반적인 노출 영역을 제공하도록 디자인된 외관 런타임인 [.NET Standard 2.0][] 대상 런타임을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-159">PowerShell Standard targets the [.NET Standard 2.0][] target runtime, which is a façade runtime designed to provide a common surface area shared by .NET Framework and .NET Core.</span></span> <span data-ttu-id="6bb56-160">이렇게 하면 단일 런타임을 대상으로 지정하여 여러 PowerShell 버전에서 작동하는 단일 어셈블리를 생성할 수 있지만 다음과 같은 결과가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-160">This allows targeting a single runtime to produce a single assembly that will work with multiple PowerShell versions, but has the following consequences:</span></span>

- <span data-ttu-id="6bb56-161">모듈 또는 라이브러리를 로드하는 PowerShell은 최소한 .NET 4.6.1을 실행해야 하며, .NET 4.6 및 .NET 4.5.2는 .NET Standard을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-161">The PowerShell loading the module or library must be running a minimum of .NET 4.6.1; .NET 4.6 and .NET 4.5.2 do not support .NET Standard.</span></span> <span data-ttu-id="6bb56-162">최신 Windows PowerShell 버전이 최신 .NET Framework 버전을 의미하지는 않으며, Windows PowerShell 5.1은 .NET 4.5.2에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-162">Note that a newer Windows PowerShell version does not mean a newer .NET Framework version; Windows PowerShell 5.1 may run on .NET 4.5.2.</span></span>
- <span data-ttu-id="6bb56-163">.NET Framework 4.7.1 이하를 실행하는 PowerShell을 사용하기 위해 netstandard.dll 및 기타 shim 어셈블리를 이전 .NET Framework 버전에 제공하려면 .NET 4.6.1 [NETStandard.Library][] 구현이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-163">In order to work with a PowerShell running .NET Framework 4.7.1 or below, the .NET 4.6.1 [NETStandard.Library][] implementation is required to provide the netstandard.dll and other shim assemblies in older .NET Framework versions.</span></span>

<span data-ttu-id="6bb56-164">PowerShell 6 이상은 .NET Framework 4.6.1 이상에서 .NET Core로 형식 전달을 위한 자체 shim 어셈블리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-164">PowerShell 6+ provides its own shim assemblies for type forwarding from .NET Framework 4.6.1 (and above) to .NET Core.</span></span> <span data-ttu-id="6bb56-165">즉, 모듈에서 .NET Core에 있는 API만 사용하는 한, 모듈이 .NET Framework 4.6.1(`net461` 런타임 대상)용으로 빌드된 경우 PowerShell 6 이상에서 모듈을 로드하여 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-165">This means that as long as a module uses only APIs that exist in .NET Core, PowerShell 6+ can load and run it when it has been built for .NET Framework 4.6.1 (the `net461` runtime target).</span></span>

<span data-ttu-id="6bb56-166">즉, 단일 게시된 DLL로 여러 PowerShell 버전을 대상으로 지정하는 데 PowerShell Standard를 사용하는 이진 모듈에는 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-166">This means that binary modules using PowerShell Standard to target multiple PowerShell versions with a single published DLL have two options:</span></span>

1. <span data-ttu-id="6bb56-167">`net461` 대상 런타임용으로 빌드된 어셈블리 게시.</span><span class="sxs-lookup"><span data-stu-id="6bb56-167">Publishing an assembly built for the `net461` target runtime.</span></span> <span data-ttu-id="6bb56-168">여기에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-168">This involves:</span></span>
   - <span data-ttu-id="6bb56-169">`net461` 런타임을 위한 프로젝트 게시</span><span class="sxs-lookup"><span data-stu-id="6bb56-169">Publishing the project for the `net461` runtime</span></span>
   - <span data-ttu-id="6bb56-170">또한 빌드 출력을 사용하지 않고 `netstandard2.0` 런타임에 대해 컴파일하여 사용되는 모든 API가 .NET Core에도 포함되도록 함</span><span class="sxs-lookup"><span data-stu-id="6bb56-170">Also compiling against the `netstandard2.0` runtime (without using its build output) to ensure that all APIs used are also present in .NET Core.</span></span>

1. <span data-ttu-id="6bb56-171">`netstandard2.0` 대상 런타임을 위한 어셈블리 빌드 게시.</span><span class="sxs-lookup"><span data-stu-id="6bb56-171">Publishing an assembly build for the `netstandard2.0` target runtime.</span></span> <span data-ttu-id="6bb56-172">여기에는 다음이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-172">This requires:</span></span>
   - <span data-ttu-id="6bb56-173">`netstandard2.0` 런타임을 위한 프로젝트 게시</span><span class="sxs-lookup"><span data-stu-id="6bb56-173">Publishing the project for the `netstandard2.0` runtime</span></span>
   - <span data-ttu-id="6bb56-174">.NET Framework에서 수정된 어셈블리가 형식으로 전달되도록 NETStandard.Library의 `net461` 종속성을 사용하고 프로젝트 어셈블리의 게시 위치에 복사</span><span class="sxs-lookup"><span data-stu-id="6bb56-174">Taking the `net461` dependencies of NETStandard.Library and copying them into the project assembly's publish location so that the assembly is type-forwarded corrected in .NET Framework.</span></span>

<span data-ttu-id="6bb56-175">이전 .NET Framework 버전을 대상으로 하는 PowerShell 모듈 또는 라이브러리를 빌드하려면 여러 .NET 런타임을 대상으로 지정하는 것이 좋을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-175">To build PowerShell modules or libraries targeting older .NET Framework versions, it may be preferable to target multiple .NET runtimes.</span></span> <span data-ttu-id="6bb56-176">이렇게 하면 각 대상 런타임을 위한 어셈블리가 게시되며 모듈 로드 시간에 올바른 어셈블리를 로드해야 합니다(예: 루트 모듈로 작은 psm1 사용).</span><span class="sxs-lookup"><span data-stu-id="6bb56-176">This will publish an assembly for each target runtime, and the correct assembly will need to be loaded at module load time (for example with a small psm1 as the root module).</span></span>

### <a name="testing-powershell-standard-projects-in-net"></a><span data-ttu-id="6bb56-177">.NET에서 PowerShell Standard 프로젝트 테스트</span><span class="sxs-lookup"><span data-stu-id="6bb56-177">Testing PowerShell Standard projects in .NET</span></span>

<span data-ttu-id="6bb56-178">xUnit 같은 .NET 테스트 러너에서 모듈을 테스트하는 경우 컴파일 시간 검사는 한계가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-178">When it comes to testing your module in .NET test runners like xUnit, remember that compile-time checks can only go so far.</span></span> <span data-ttu-id="6bb56-179">관련 PowerShell 플랫폼에서 모듈을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-179">You must test your module against the relevant PowerShell platforms.</span></span>

<span data-ttu-id="6bb56-180">.NET의 PowerShell Standard에서 빌드된 API를 테스트하려면 .NET Core(원하는 PowerShell 버전과 일치하도록 설정된 버전 포함)를 사용하여 테스트 종속성으로 `Microsoft.Powershell.SDK`를 추가하고 .NET Framework를 사용하여 적절한 Windows PowerShell 참조 어셈블리를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-180">To test APIs built against PowerShell Standard in .NET, you should add `Microsoft.Powershell.SDK` as a testing dependency with .NET Core (with the version set to match the desired PowerShell version), and the appropriate Windows PowerShell reference assemblies with .NET Framework.</span></span>

<span data-ttu-id="6bb56-181">PowerShell Standard 및 해당 항목을 사용하여 여러 PowerShell 버전에서 작동하는 이진 모듈을 작성하는 방법에 관한 자세한 내용은 [이 블로그 게시물][]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6bb56-181">For more information on PowerShell Standard and using it to write a binary module that works in multiple PowerShell versions, see [this blog post][].</span></span> <span data-ttu-id="6bb56-182">또한 GitHub에서 [PowerShell Standard 리포지토리][]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6bb56-182">Also see the [PowerShell Standard repository][] on GitHub.</span></span>

## <a name="microsoftpowershellsdk"></a><span data-ttu-id="6bb56-183">Microsoft.PowerShell.SDK</span><span class="sxs-lookup"><span data-stu-id="6bb56-183">Microsoft.PowerShell.SDK</span></span>

<span data-ttu-id="6bb56-184">`Microsoft.PowerShell.SDK`는 PowerShell SDK의 모든 구성 요소를 단일 NuGet 패키지로 함께 가져오는 메타 패키지입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-184">`Microsoft.PowerShell.SDK` is a meta-package that pulls together all of the components of the PowerShell SDK into a single NuGet package.</span></span> <span data-ttu-id="6bb56-185">자체 포함 .NET 애플리케이션은 외부 PowerShell 설치 또는 라이브러리에 의존하지 않고 Microsoft.PowerShell.SDK를 사용하여 임의 PowerShell 기능을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-185">A self-contained .NET application can use Microsoft.PowerShell.SDK to run arbitrary PowerShell functionality without depending on any external PowerShell installations or libraries.</span></span>

> [!NOTE]
> <span data-ttu-id="6bb56-186">PowerShell SDK는 PowerShell을 구성하고 PowerShell을 사용한 .NET 개발에 사용할 수 있는 모든 구성 요소 패키지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-186">The PowerShell SDK just refers to all the component packages that make up PowerShell, and which can be used for .NET development with PowerShell.</span></span>

<span data-ttu-id="6bb56-187">지정된 `Microsoft.Powershell.SDK` 버전에는 동일한 PowerShell 애플리케이션 버전의 구체적인 구현이 포함되며, 버전 7.0에는 PowerShell 7.0 구현이 포함되며 해당 버전에서 실행하는 명령이나 스크립트는 대체로 PowerShell 7.0에서 실행하는 것처럼 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-187">A given `Microsoft.Powershell.SDK` version contains the concrete implementation of the same version of the PowerShell application; version 7.0 contains the implementation of PowerShell 7.0 and running commands or scripts with it will largely behave like running them in PowerShell 7.0.</span></span>

<span data-ttu-id="6bb56-188">SDK에서 PowerShell 명령을 실행하는 것은 완전히는 아니지만 일반적으로 `pwsh`에서 실행하는 것과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-188">Running PowerShell commands from the SDK is mostly, but not totally, the same as running them from `pwsh`.</span></span> <span data-ttu-id="6bb56-189">예를 들어 [Start-Job][]은 현재 제공되는 `pwsh` 실행 파일을 사용하므로 기본적으로 `Microsoft.Powershell.SDK`에서 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-189">For example, [Start-Job][] currently depends on the `pwsh` executable being available, and so will not work with `Microsoft.Powershell.SDK` by default.</span></span>

<span data-ttu-id="6bb56-190">.NET 애플리케이션에서 `Microsoft.Powershell.SDK`를 대상으로 지정하면 `System.Management.Automation`, `Microsoft.PowerShell.Management` 및 기타 모듈 어셈블리와 같은 PowerShell의 모든 구현 어셈블리와 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-190">Targeting `Microsoft.Powershell.SDK` from a .NET application allows you to integrate with all of PowerShell's implementation assemblies, such as `System.Management.Automation`, `Microsoft.PowerShell.Management`, and other module assemblies.</span></span>

<span data-ttu-id="6bb56-191">`Microsoft.Powershell.SDK`를 대상으로 하는 애플리케이션 게시에는 모든 해당 어셈블리 및 PowerShell에 필요한 모든 종속성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-191">Publishing an application targeting `Microsoft.Powershell.SDK` will include all these assemblies, and any dependencies PowerShell requires.</span></span> <span data-ttu-id="6bb56-192">또한 `Microsoft.PowerShell.*` 모듈의 모듈 매니페스트 및 [Add-Type][]에 필요한 `ref` 디렉터리와 같이 PowerShell이 해당 빌드에서 필요한 다른 자산이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-192">It will also include other assets that PowerShell required in its build, such as the module manifests for `Microsoft.PowerShell.*` modules and the `ref` directory required by [Add-Type][].</span></span>

<span data-ttu-id="6bb56-193">`Microsoft.Powershell.SDK` 완결성의 경우 다음에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-193">Given the completeness of `Microsoft.Powershell.SDK`, it's best suited for:</span></span>

- <span data-ttu-id="6bb56-194">PowerShell 호스트의 구현</span><span class="sxs-lookup"><span data-stu-id="6bb56-194">Implementation of PowerShell hosts.</span></span>
- <span data-ttu-id="6bb56-195">PowerShell 참조 어셈블리를 대상으로 하는 라이브러리의 xUnit 테스트</span><span class="sxs-lookup"><span data-stu-id="6bb56-195">xUnit testing of libraries targeting PowerShell reference assemblies.</span></span>
- <span data-ttu-id="6bb56-196">.NET 애플리케이션에서 PowerShell In Process 호출</span><span class="sxs-lookup"><span data-stu-id="6bb56-196">Invoking PowerShell in-process from a .NET application.</span></span>

<span data-ttu-id="6bb56-197">`Microsoft.PowerShell.SDK`는 .NET 프로젝트를 모듈로 사용하거나 PowerShell을 통해 로드해야 하지만 특정 버전의 PowerShell에 있는 API만 사용하는 경우 참조 대상으로 사용될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-197">`Microsoft.PowerShell.SDK` may also be used as a reference target when a .NET project is intended to be used as a module or otherwise loaded by PowerShell, but depends on APIs only present in a particular version of PowerShell.</span></span> <span data-ttu-id="6bb56-198">특정 버전의 `Microsoft.PowerShell.SDK`에 대해 게시된 어셈블리는 해당 버전의 PowerShell에서만 안전하게 로드 및 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-198">Note that an assembly published against a specific version of `Microsoft.PowerShell.SDK` will only be safe to load and use in that version of PowerShell.</span></span> <span data-ttu-id="6bb56-199">특정 API가 포함된 여러 PowerShell 버전을 대상으로 지정하려면 각각 자체 버전의 `Microsoft.Powershell.SDK`를 대상으로 하는 여러 빌드가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-199">To target multiple PowerShell versions with specific APIs, multiple builds are required, each targeting their own version of `Microsoft.Powershell.SDK`.</span></span>

> [!NOTE]
> <span data-ttu-id="6bb56-200">PowerShell SDK는 PowerShell 버전 6 이상에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-200">The PowerShell SDK is only available for PowerShell versions 6 and up.</span></span> <span data-ttu-id="6bb56-201">Windows PowerShell에서 동일한 기능을 제공하려면 아래에 설명된 Windows PowerShell 참조 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-201">To provide equivalent functionality with Windows PowerShell, use the Windows PowerShell reference assemblies described below.</span></span>

## <a name="systemmanagementautomation"></a><span data-ttu-id="6bb56-202">System.Management.Automation</span><span class="sxs-lookup"><span data-stu-id="6bb56-202">System.Management.Automation</span></span>

<span data-ttu-id="6bb56-203">`System.Management.Automation` 패키지는 PowerShell SDK의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-203">The `System.Management.Automation` package is the heart of the PowerShell SDK.</span></span> <span data-ttu-id="6bb56-204">주로 `Microsoft.Powershell.SDK`가 가져올 자산으로 NuGet에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-204">It exists on NuGet, primarily, as an asset for `Microsoft.Powershell.SDK` to pull in.</span></span> <span data-ttu-id="6bb56-205">그러나 더 작은 호스팅 시나리오 및 버전 대상 모듈용 패키지로 직접 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-205">However, it can also be used directly as a package for smaller hosting scenarios and version-targeting modules.</span></span>

<span data-ttu-id="6bb56-206">특히 다음과 같은 경우 `System.Management.Automation` 패키지를 PowerShell 기능의 공급자로 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-206">Specifically, the `System.Management.Automation` package may be a preferable provider of PowerShell functionality when:</span></span>

- <span data-ttu-id="6bb56-207">PowerShell 파서, AST 및 AST 방문자 API(예: PowerShell의 정적 분석용)와 같은 PowerShell 언어 기능을 `System.Management.Automation.Language` 네임스페이스에서 사용하는 것만 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-207">You're only looking to use PowerShell language functionality (in the `System.Management.Automation.Language` namespace) like the PowerShell parser, AST, and AST visitor APIs (for example for static analysis of PowerShell).</span></span>
- <span data-ttu-id="6bb56-208">`Microsoft.PowerShell.Core` 모듈에서 특정 명령만 실행하려고 하며 [CreateDefault2][] 팩터리 메서드를 사용하여 만든 세션 상태에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-208">You only wish to execute specific commands from the `Microsoft.PowerShell.Core` module and can execute them in a session state created with the [CreateDefault2][] factory method.</span></span>

<span data-ttu-id="6bb56-209">또한 `System.Management.Automation`은 다음과 같은 경우에 유용한 참조 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-209">Additionally, `System.Management.Automation` is a useful reference assembly when:</span></span>

- <span data-ttu-id="6bb56-210">특정 PowerShell 버전에만 있는 API를 대상으로 지정하려는 경우</span><span class="sxs-lookup"><span data-stu-id="6bb56-210">You wish to target APIs that are only present within a specific PowerShell version</span></span>
- <span data-ttu-id="6bb56-211">`System.Management.Automation` 어셈블리 외부에서 발생하는 형식을 사용하지 않으려는 경우(예: `Microsoft.PowerShell.*` 모듈의 cmdlet을 통해 내보낸 형식).</span><span class="sxs-lookup"><span data-stu-id="6bb56-211">You won't be depending on types occurring outside the `System.Management.Automation` assembly (for example, types exported by cmdlets in `Microsoft.PowerShell.*` modules).</span></span>

## <a name="windows-powershell-reference-assemblies"></a><span data-ttu-id="6bb56-212">Windows PowerShell 참조 어셈블리</span><span class="sxs-lookup"><span data-stu-id="6bb56-212">Windows PowerShell reference assemblies</span></span>

<span data-ttu-id="6bb56-213">PowerShell 버전 5.1 이하(Windows PowerShell)의 경우 Windows PowerShell 구현이 Windows에 포함되므로 PowerShell 구현을 제공하는 SDK가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-213">For PowerShell versions 5.1 and older (Windows PowerShell), there is no SDK to provide an implementation of PowerShell, since Windows PowerShell's implementation is a part of Windows.</span></span>

<span data-ttu-id="6bb56-214">대신, Windows PowerShell 참조 어셈블리는 참조 대상 및 Windows PowerShell을 다시 호스트하는 방법을 둘 다 제공하여 PowerShell SDK가 버전 6 이상에서 작동하는 것과 동일하게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-214">Instead, the Windows PowerShell reference assemblies provide both reference targets and a way to rehost Windows PowerShell, acting the same as the PowerShell SDK does for versions 6 and up.</span></span>

<span data-ttu-id="6bb56-215">버전별로 구분되는 것이 아니라 Windows PowerShell 참조 어셈블리에는 각 Windows PowerShell 버전에 해당하는 다른 패키지가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-215">Rather than being differentiated by version, Windows PowerShell reference assemblies have a different package for each version of Windows PowerShell:</span></span>

- [<span data-ttu-id="6bb56-216">PowerShell 5.1</span><span class="sxs-lookup"><span data-stu-id="6bb56-216">PowerShell 5.1</span></span>](https://www.nuget.org/packages/Microsoft.PowerShell.5.ReferenceAssemblies/)
- [<span data-ttu-id="6bb56-217">PowerShell 4</span><span class="sxs-lookup"><span data-stu-id="6bb56-217">PowerShell 4</span></span>](https://www.nuget.org/packages/Microsoft.PowerShell.4.ReferenceAssemblies/)
- [<span data-ttu-id="6bb56-218">PowerShell 3</span><span class="sxs-lookup"><span data-stu-id="6bb56-218">PowerShell 3</span></span>](https://www.nuget.org/packages/Microsoft.PowerShell.3.ReferenceAssemblies/)

<span data-ttu-id="6bb56-219">Windows PowerShell 참조 어셈블리를 사용하는 방법에 관한 정보는 [Windows PowerShell SDK][]에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-219">Information on how to use the Windows PowerShell reference assemblies can be found in the [Windows PowerShell SDK][].</span></span>

## <a name="real-world-examples-using-these-nuget-packages"></a><span data-ttu-id="6bb56-220">해당 NuGet 패키지를 사용하는 실제 예제</span><span class="sxs-lookup"><span data-stu-id="6bb56-220">Real-world examples using these NuGet packages</span></span>

<span data-ttu-id="6bb56-221">다양한 PowerShell 도구 프로젝트는 요구 사항에 따라 다양한 PowerShell NuGet 패키지를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-221">Different PowerShell tooling projects target different PowerShell NuGet packages depending on their needs.</span></span> <span data-ttu-id="6bb56-222">여기에 몇 가지 주목할 만한 예가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-222">Listed here are some notable examples.</span></span>

### <a name="psreadline"></a><span data-ttu-id="6bb56-223">PSReadLine</span><span class="sxs-lookup"><span data-stu-id="6bb56-223">PSReadLine</span></span>

<span data-ttu-id="6bb56-224">[PSReadLine][] - PowerShell의 풍부한 콘솔 환경을 많이 제공하고, 특정 PowerShell 버전이 아닌 종속성으로 PowerShell Standard를 대상으로 지정하고, [csproj][]에서 `net461` .NET 런타임을 대상으로 하는 PowerShell 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-224">[PSReadLine][], the PowerShell module that provides much of PowerShell's rich console experience, targets PowerShell Standard as a dependency rather than a specific PowerShell version, and targets the `net461` .NET runtime in its [csproj][].</span></span>

<span data-ttu-id="6bb56-225">PowerShell 6 이상은 .NET Framework의 `mscorlib.dll`에 대한 바인딩을 관련 .NET Core 어셈블리로 리디렉션하여 `net461` 런타임을 대상으로 하는 DLL이 로드될 때 “바로 작동”하도록 허용하는 자체 shim 어셈블리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-225">PowerShell 6+ supplies its own shim assemblies that allow a DLL targeting the `net461` runtime to "just work" when loaded in (by redirecting binding to .NET Framework's `mscorlib.dll` to the relevant .NET Core assembly).</span></span>

<span data-ttu-id="6bb56-226">PowerShell Standard는 사용되는 API만 PowerShell 5.1 및 PowerShell 6 이상에서 둘 다 제공되도록 하지만 모듈이 단일 어셈블리에만 함께 제공될 수 있도록 하므로 이렇게 하면 PSReadLine의 모듈 레이아웃 및 전송이 크게 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-226">This simplifies PSReadLine's module layout and delivery significantly, since PowerShell Standard ensures the only APIs used will be present in both PowerShell 5.1 and PowerShell 6+, while also allowing the module to ship with only a single assembly.</span></span>

<span data-ttu-id="6bb56-227">.NET 4.6.1 대상의 경우 .NET 4.5.2 및 .NET 4.6에서 실행되는 Windows PowerShell이 지원되지 않는다는 의미가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-227">The .NET 4.6.1 target does mean that Windows PowerShell running on .NET 4.5.2 and .NET 4.6 is not supported though.</span></span>

### <a name="powershell-editor-services"></a><span data-ttu-id="6bb56-228">PowerShell Editor Services</span><span class="sxs-lookup"><span data-stu-id="6bb56-228">PowerShell Editor Services</span></span>

<span data-ttu-id="6bb56-229">PSES([PowerShell Editor Services][])는 [Visual Studio Code][]용 [PowerShell 확장][]의 백 엔드이며, 실제로 PowerShell 실행 파일을 통해 로드된 후 해당 프로세스를 인수하여 언어 서비스 프로토콜 및 디버그 어댑터 기능을 제공하면서 내부에 PowerShell을 다시 호스트하는 PowerShell 모듈 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-229">[PowerShell Editor Services][] (PSES) is the backend for the [PowerShell extension][] for [Visual Studio Code][], and is actually a form of PowerShell module that gets loaded by a PowerShell executable and then takes over that process to rehost PowerShell within itself while also providing Language Service Protocol and Debug Adapter features.</span></span>

<span data-ttu-id="6bb56-230">PSES는 `netcoreapp2.1`이 PowerShell 6 이상을 대상으로 지정하고(PowerShell 7의 `netcoreapp3.1` 런타임이 이전 버전과 호환되기 때문) `net461`이 Windows PowerShell 5.1을 대상으로 지정하도록 구체적인 구현 대상을 제공하지만, `netstandard2.0` 및 PowerShell Standard를 대상으로 하는 두 번째 어셈블리에서 대부분의 논리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-230">PSES provides concrete implementation targets for `netcoreapp2.1` to target PowerShell 6+ (since PowerShell 7's `netcoreapp3.1` runtime is backwards compatible) and `net461` to target Windows PowerShell 5.1, but contains most of its logic in a second assembly that targets `netstandard2.0` and PowerShell Standard.</span></span> <span data-ttu-id="6bb56-231">이를 통해 .NET Core 및 .NET Framework 플랫폼에 필요한 종속성을 가져올 수 있지만 균일 추상화를 기반으로 대부분의 코드베이스를 단순화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-231">This allows it to pull in dependencies required for .NET Core and .NET Framework platforms, while still simplifying most of the codebase behind a uniform abstraction.</span></span>

<span data-ttu-id="6bb56-232">PowerShell Standard에 대해 빌드되기 때문에 PSES를 제대로 테스트하려면 PowerShell의 런타임 구현이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-232">Because it is built against PowerShell Standard, PSES requires a runtime implementation of PowerShell in order to be tested correctly.</span></span> <span data-ttu-id="6bb56-233">해당 작업을 수행하기 위해 [PSES의 xUnit][] 테스트는 `Microsoft.PowerShell.SDK` 및 `Microsoft.PowerShell.5.ReferenceAssemblies`를 가져와서 테스트 환경에서 PowerShell 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-233">To do this, [PSES's xUnit][] tests pull in `Microsoft.PowerShell.SDK` and `Microsoft.PowerShell.5.ReferenceAssemblies` in order to provide a PowerShell implementation in the test environment.</span></span>

<span data-ttu-id="6bb56-234">PSReadLine과 마찬가지로 PSES는 .NET 4.6 이하를 지원할 수 없지만 더 낮은 .NET Framework 런타임에서 크래쉬를 일으킬 수 있는 모든 API를 호출하기 전에 런타임에 [검사를 수행][]합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-234">As with PSReadLine, PSES cannot support .NET 4.6 and below, but it [performs a check][] at runtime before calling any of the APIs that could cause a crash on the lower .NET Framework runtimes.</span></span>

### <a name="psscriptanalyzer"></a><span data-ttu-id="6bb56-235">PSScriptAnalyzer</span><span class="sxs-lookup"><span data-stu-id="6bb56-235">PSScriptAnalyzer</span></span>

<span data-ttu-id="6bb56-236">PowerShell의 linter인 [PSScriptAnalyzer][]는 특정 버전의 PowerShell에만 도입된 구문 요소를 대상으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-236">[PSScriptAnalyzer][], the linter for PowerShell, must target syntactic elements only introduced in certain versions of PowerShell.</span></span> <span data-ttu-id="6bb56-237">[AstVisitor2][]를 구현하여 해당 구문 요소를 인식하기 때문에 PowerShellStandard를 사용할 수 없으며 최신 PowerShell 구문을 위한 AST 방문자 메서드도 구현할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-237">Because recognition of these syntactic elements is accomplished by implementing an [AstVisitor2][], it's not possible to use PowerShellStandard and also implement AST visitor methods for newer PowerShell syntaxes.</span></span>

<span data-ttu-id="6bb56-238">대신, PSScriptAnalyzer는 빌드 구성으로 [각 PowerShell 버전을 대상으로 지정][]하며 각 버전에 대해 별도 DLL을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-238">Instead, PSScriptAnalyzer [targets each PowerShell version][] as a build configuration, and produces a separate DLL for each of them.</span></span> <span data-ttu-id="6bb56-239">이렇게 하면 빌드 크기 및 복잡성이 증가하지만 다음이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-239">This increases build size and complexity, but allows:</span></span>

- <span data-ttu-id="6bb56-240">버전별 API 대상 지정</span><span class="sxs-lookup"><span data-stu-id="6bb56-240">Version-specific API targeting</span></span>
- <span data-ttu-id="6bb56-241">기본적으로 런타임 비용 없이 버전별 기능 구현</span><span class="sxs-lookup"><span data-stu-id="6bb56-241">Version-specific functionality to be implemented with essentially no runtime cost</span></span>
- <span data-ttu-id="6bb56-242">.NET Framework 4.5.2까지 전체 Windows PowerShell 지원</span><span class="sxs-lookup"><span data-stu-id="6bb56-242">Total support for Windows PowerShell all the way down to .NET Framework 4.5.2</span></span>

## <a name="summary"></a><span data-ttu-id="6bb56-243">요약</span><span class="sxs-lookup"><span data-stu-id="6bb56-243">Summary</span></span>

<span data-ttu-id="6bb56-244">이 문서에서는 PowerShell을 사용하는 .NET 프로젝트를 구현할 때 대상에서 사용할 수 있는 NuGet 패키지 및 각 패키지를 사용할 수 있는 이유를 나열하고 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-244">In this article, we've listed and discussed the NuGet packages available to target when implementing a .NET project that uses PowerShell, and the reasons you might have for using one over another.</span></span>

<span data-ttu-id="6bb56-245">요약으로 건너뛴 경우 몇 가지 광범위한 권장 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-245">If you've skipped to the summary, some broad recommendations are:</span></span>

- <span data-ttu-id="6bb56-246">PowerShell **모듈**은 다양한 PowerShell 버전에 공통된 API만 필요한 경우 PowerShell Standard에 대해 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-246">PowerShell **modules** should compile against PowerShell Standard if they only require APIs common to different PowerShell versions.</span></span>
- <span data-ttu-id="6bb56-247">내부적으로 PowerShell을 실행해야 하는 PowerShell **호스트 및 애플리케이션**은 PowerShell 6 이상의 경우 PowerShell SDK를, Windows PowerShell의 경우 관련 Windows PowerShell 참조 어셈블리를 대상으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-247">PowerShell **hosts and applications** that need to run PowerShell internally should target the PowerShell SDK for PowerShell 6+ or the relevant Windows PowerShell reference assemblies for Windows PowerShell.</span></span>
- <span data-ttu-id="6bb56-248">**버전별 API**가 필요한 PowerShell 모듈은 필요한 PowerShell 버전에 해당하는 PowerShell SDK 또는 Windows PowerShell 참조 어셈블리를 참조 어셈블리로 사용하여(PowerShell 종속성을 게시하는 것이 아님) 대상으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6bb56-248">PowerShell modules that need **version-specific APIs** should target the PowerShell SDK or Windows PowerShell reference assemblies for the required PowerShell versions, using them as reference assemblies (that is, not publishing the PowerShell dependencies).</span></span>

<!--link references -->

[.NET Standard 2.0]: /dotnet/standard/net-standard
[about_Modules]: /powershell/module/microsoft.powershell.core/about/about_modules
[Add-Type]: /powershell/module/microsoft.powershell.utility/add-type
[AstVisitor2]: /dotnet/api/system.management.automation.language.astvisitor2
[CmdletProvider]: /dotnet/api/system.management.automation.provider.cmdletprovider
[CreateDefault2]: /dotnet/api/system.management.automation.runspaces.initialsessionstate.createdefault2
[csproj]: https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/PSReadLine.csproj
[Microsoft.PowerShell.SDK]: https://www.nuget.org/packages/Microsoft.PowerShell.SDK/
[NETStandard.Library]: https://www.nuget.org/packages/NETStandard.Library/
[NuGet]: https://www.nuget.org/
[검사 수행]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/src/PowerShellEditorServices.Hosting/EditorServicesLoader.cs#L231-L251
[performs a check]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/src/PowerShellEditorServices.Hosting/EditorServicesLoader.cs#L231-L251
[Pester]: https://github.com/Pester/Pester
[PowerShell Editor Services]: https://github.com/PowerShell/PowerShellEditorServices/
[PowerShell 확장]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
[PowerShell extension]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
[PowerShell NuGet]: https://www.nuget.org/packages/PowerShell/
[PowerShell Standard 리포지토리]: https://github.com/PowerShell/PowerShellStandard
[PowerShell Standard repository]: https://github.com/PowerShell/PowerShellStandard
[PowerShellStandard.Library]: https://www.nuget.org/packages/PowerShellStandard.Library/
[PSCmdlet]: /dotnet/api/system.management.automation.pscmdlet
[PSES의 xUnit]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/test/PowerShellEditorServices.Test/PowerShellEditorServices.Test.csproj#L15-L20
[PSES's xUnit]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/test/PowerShellEditorServices.Test/PowerShellEditorServices.Test.csproj#L15-L20
[PSHost]: /dotnet/api/system.management.automation.host.pshost
[PrivateAssets 특성]: /dotnet/core/tools/csproj#packagereference
[PrivateAssets attribute]: /dotnet/core/tools/csproj#packagereference
[PSReadLine]: https://github.com/PowerShell/PSReadLine
[PSScriptAnalyzer]: https://github.com/powershell/psscriptanalyzer
[참조 어셈블리]: https://github.com/dotnet/standard/blob/master/docs/history/evolution-of-design-time-assemblies.md#definitions
[reference assemblies]: https://github.com/dotnet/standard/blob/master/docs/history/evolution-of-design-time-assemblies.md#definitions
[Start-Job]: /powershell/module/microsoft.powershell.core/start-job
[System.Management.Automation]: https://www.nuget.org/packages/System.Management.Automation/
[각 PowerShell 버전을 대상으로 지정]: https://github.com/PowerShell/PSScriptAnalyzer/blob/master/Engine/Engine.csproj
[targets each PowerShell version]: https://github.com/PowerShell/PSScriptAnalyzer/blob/master/Engine/Engine.csproj
[이 블로그 게시물]: https://devblogs.microsoft.com/powershell/powershell-standard-library-build-single-module-that-works-across-windows-powershell-and-powershell-core/
[this blog post]: https://devblogs.microsoft.com/powershell/powershell-standard-library-build-single-module-that-works-across-windows-powershell-and-powershell-core/
[Visual Studio Code]: https://code.visualstudio.com/
[Windows PowerShell SDK]: /powershell/scripting/developer/windows-powershell
