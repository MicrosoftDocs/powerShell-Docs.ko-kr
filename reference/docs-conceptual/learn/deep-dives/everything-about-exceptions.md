---
title: 예외에 대해 알고 싶은 모든 것
description: 코드 작성에서 오류 처리는 일상적인 일입니다.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: 94c39b0d36b948d3a62707ae8a3be00efe606434
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/11/2020
ms.locfileid: "90012564"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="a1d7e-103">예외에 대해 알고 싶은 모든 것</span><span class="sxs-lookup"><span data-stu-id="a1d7e-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="a1d7e-104">코드 작성에서 오류 처리는 일상적인 일입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="a1d7e-105">예상되는 동작에 대한 조건을 자주 확인하고 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="a1d7e-106">예기치 않은 상황이 발생하면 예외 처리로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="a1d7e-107">다른 사용자의 코드에서 생성한 예외를 쉽게 처리하거나 다른 사용자가 처리할 예외를 직접 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="a1d7e-108">이 문서의 [원래 버전][]은 [@KevinMarquette][]가 작성한 블로그에 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="a1d7e-109">PowerShell 팀은 이 콘텐츠를 공유해 준 Kevin에게 감사의 말을 전합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="a1d7e-110">[PowerShellExplained.com][]에 있는 그의 블로그를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="a1d7e-111">기본 용어</span><span class="sxs-lookup"><span data-stu-id="a1d7e-111">Basic terminology</span></span>

<span data-ttu-id="a1d7e-112">이 주제를 살펴보기 전에 먼저 몇 가지 기본적인 용어를 살펴봐야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="a1d7e-113">예외</span><span class="sxs-lookup"><span data-stu-id="a1d7e-113">Exception</span></span>

<span data-ttu-id="a1d7e-114">예외는 일반적인 오류 처리로는 문제를 처리할 수 없을 때 생성되는 이벤트와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="a1d7e-115">예외를 생성하는 대표적인 예는 숫자를 0으로 나누려고 하거나 메모리가 부족한 상황입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="a1d7e-116">사용 중인 코드 작성자가 특정 문제 발생 시 예외를 생성하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="a1d7e-117">Throw 및 Catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-117">Throw and Catch</span></span>

<span data-ttu-id="a1d7e-118">예외가 발생하면 예외가 throw되었다고 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="a1d7e-119">Throw된 예외를 처리하려면 예외를 catch해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="a1d7e-120">예외가 throw되고 어떻게든 catch되지 않으면 스크립트 실행이 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="a1d7e-121">호출 스택</span><span class="sxs-lookup"><span data-stu-id="a1d7e-121">The call stack</span></span>

<span data-ttu-id="a1d7e-122">호출 스택은 서로를 호출한 함수 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="a1d7e-123">호출된 함수는 스택이나 목록 맨 위에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="a1d7e-124">함수는 종료되거나 반환되면 스택에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="a1d7e-125">예외가 throw되면 관련 호출 스택을 확인해 예외 처리기가 예외를 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="a1d7e-126">종료 또는 종료되지 않는 오류</span><span class="sxs-lookup"><span data-stu-id="a1d7e-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="a1d7e-127">예외 대부분 종료 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="a1d7e-128">Throw된 예외를 catch하지 않으면 현재 실행이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="a1d7e-129">기본적으로 종료되지 않는 오류는 `Write-Error`에 의해 생성되며, 예외를 throw하지 않고 출력 스트림에 오류를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="a1d7e-130">이 점을 강조하는 이유는 `Write-Error` 및 다른 종료되지 않는 오류는 `catch`를 트리거하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="a1d7e-131">예외 받아들이기</span><span class="sxs-lookup"><span data-stu-id="a1d7e-131">Swallowing an exception</span></span>

<span data-ttu-id="a1d7e-132">오류를 단순히 무시하기 위해 catch하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="a1d7e-133">문제 해결이 대단히 어려워질 수 있으니 이 작업은 주의해서 진행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="a1d7e-134">기본 명령 구문</span><span class="sxs-lookup"><span data-stu-id="a1d7e-134">Basic command syntax</span></span>

<span data-ttu-id="a1d7e-135">다음은 PowerShell에서 사용하는 기본 예외 처리 구문에 관한 간략한 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="a1d7e-136">Throw</span><span class="sxs-lookup"><span data-stu-id="a1d7e-136">Throw</span></span>

<span data-ttu-id="a1d7e-137">자체 예외 이벤트를 만들려면 `throw` 키워드로 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="a1d7e-138">종료 오류인 런타임 예외가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="a1d7e-139">호출 함수에서 `catch`로 처리하지 않으면 다음과 비슷한 메시지와 함께 스크립트가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="a1d7e-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="a1d7e-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="a1d7e-141">앞에서 `Write-Error`는 기본적으로 종료 오류를 throw하지 않는다고 했죠.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="a1d7e-142">`-ErrorAction Stop`을 지정하면 `Write-Error`는 `catch`로 처리할 수 있는 종료 오류를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="a1d7e-143">이 방법으로 `-ErrorAction Stop`을 사용할 수 있음을 알려준 Lee Dailey에게 감사의 말을 전합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="a1d7e-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="a1d7e-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="a1d7e-145">고급 함수 또는 cmdlet에 `-ErrorAction Stop`을 지정하면 모든 `Write-Error` 문이 실행을 중지하거나 `catch`로 처리할 수 있는 종료 오류로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="a1d7e-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-146">Try/Catch</span></span>

<span data-ttu-id="a1d7e-147">PowerShell로 (그리고 다른 많은 언어로) 오류 처리 수행할 때 사용자는 먼저 코드 일부를 `try`한 다음 오류가 throw되면 `catch`합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="a1d7e-148">다음은 이에 관한 간단한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="a1d7e-149">`catch` 스크립트는 종료 오류가 있을 때만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="a1d7e-150">`try`가 올바르게 실행된다면 `catch`는 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="a1d7e-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="a1d7e-151">Try/Finally</span></span>

<span data-ttu-id="a1d7e-152">오류를 처리할 필요는 없지만 예외 발생 여부에 따라 코드를 실행해야 할 때도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="a1d7e-153">`finally` 스크립트는 바로 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="a1d7e-154">이 예제를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="a1d7e-155">리소스를 열거나 연결했다면 항상 해당 리소스를 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="a1d7e-156">`ExecuteNonQuery()`에서 예외를 throw한다면 연결이 닫히지 않았다는 뜻입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="a1d7e-157">다음은 `try/finally` 블록에 있는 동일한 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="a1d7e-158">이 예제에서는 오류가 있다면 연결이 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="a1d7e-159">오류가 없어도 연결은 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-159">It also is closed if there's no error.</span></span> <span data-ttu-id="a1d7e-160">`finally` 스크립트는 매번 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="a1d7e-161">여러분이 예외를 catch하지 않기 때문에 여전히 호출 스택으로 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="a1d7e-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="a1d7e-162">Try/Catch/Finally</span></span>

<span data-ttu-id="a1d7e-163">`catch`와 `finally`를 함께 사용해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="a1d7e-164">대부분의 경우 하나만 사용하지만 두 가지를 모두 사용하는 시나리오도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="a1d7e-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="a1d7e-165">$PSItem</span></span>

<span data-ttu-id="a1d7e-166">이제 기본 사항을 확인했으니 좀 더 자세한 내용을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="a1d7e-167">`catch` 블록에는 예외 관련 세부 정보를 포함하는 `ErrorRecord` 유형의 자동 변수(`$PSItem`또는 `$_`)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="a1d7e-168">다음은 몇 가지 주요 속성에 대한 간략한 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="a1d7e-169">예제에서는 이 예외를 생성하기 위해 `ReadAllText`에 잘못된 경로를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="a1d7e-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="a1d7e-170">PSItem.ToString()</span></span>

<span data-ttu-id="a1d7e-171">로깅 및 일반 출력에 사용할 가장 깔끔한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="a1d7e-172">`ToString()`은 `$PSItem`이 문자열 안에 배치되면 자동으로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="a1d7e-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="a1d7e-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="a1d7e-174">이 속성은 예외가 throw된 함수 또는 스크립트에 대해 PowerShell에서 수집한 추가 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="a1d7e-175">다음은 제가 만든 샘플 예외의 `InvocationInfo`입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="a1d7e-176">중요 세부 정보에서 `ScriptName`, 코드 `Line`과 호출이 시작된 `ScriptLineNumber`를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="a1d7e-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="a1d7e-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="a1d7e-178">이 속성은 예외가 생성된 코드를 알려주는 함수 호출의 순서를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="a1d7e-179">저는 동일한 스크립트에 있는 함수를 호출하지만 여러 스크립트가 관련된다면 호출을 추적할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="a1d7e-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="a1d7e-180">$PSItem.Exception</span></span>

<span data-ttu-id="a1d7e-181">Throw된 실제 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="a1d7e-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="a1d7e-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="a1d7e-183">예외를 설명해주며 훌륭한 문제 해결 출발점인 일반 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="a1d7e-184">대부분의 예외에는 기본 메시지가 있지만 예외가 throw될 때 표시할 사용자 지정 메시지를 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="a1d7e-185">이 메시지는 `ErrorRecord`에 설정하지 않았다면 `$PSItem.ToString()`을 호출할 때 반환되는 메시지이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="a1d7e-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="a1d7e-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="a1d7e-187">예외는 내부 예외를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="a1d7e-188">호출하는 코드가 예외를 catch하고 다른 예외를 throw할 때 자주 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="a1d7e-189">원래 예외는 새 예외 안에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="a1d7e-190">이 주제는 예외를 다시 throw하는 방법을 설명할 때 다시 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="a1d7e-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="a1d7e-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="a1d7e-192">예외에 대한 `StackTrace`입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="a1d7e-193">앞에서 `ScriptStackTrace`를 보여드렸지만, $PSItem.Exception.StackTrace는 관리 코드 호출에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="a1d7e-194">관리 코드에서 이벤트가 throw될 때만 이 스택 추적을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="a1d7e-195">.NET framework 함수를 직접 호출했기 때문에 이 예제에서 이것밖에 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="a1d7e-196">일반적으로 스택 추적을 확인할 때는 코드가 중단된 지점과 시스템 호출이 시작된 지점을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="a1d7e-197">예외 처리 작업</span><span class="sxs-lookup"><span data-stu-id="a1d7e-197">Working with exceptions</span></span>

<span data-ttu-id="a1d7e-198">예외는 기본 구문 및 예외 속성만으로 구성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="a1d7e-199">형식화된 예외 catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-199">Catching typed exceptions</span></span>

<span data-ttu-id="a1d7e-200">Catch할 예외를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="a1d7e-201">예외에는 형식이 있으며 사용자는 catch할 예외의 형식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="a1d7e-202">사용자의 예상과 일치하는 항목이 발견될 때까지 각 `catch` 블록을 상대로 예외 형식을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="a1d7e-203">예외를 다른 예외에서 상속할 수 있다는 점도 반드시 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="a1d7e-204">위의 예제에서 `FileNotFoundException`은 `IOException`에서 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="a1d7e-205">따라서 `IOException`이 첫 번째라면 이것이 대신 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="a1d7e-206">여러 항목이 일치하더라도 catch 블록은 하나만 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="a1d7e-207">`System.IO.PathTooLongException`이 있었다면 `IOException`이 일치할 수 있지만 `InsufficientMemoryException`이 있었다면 이것은 catch되지 않고 스택에서 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="a1d7e-208">한 번에 여러 형식 catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-208">Catch multiple types at once</span></span>

<span data-ttu-id="a1d7e-209">동일한 `catch` 문으로 여러 예외 형식을 catch할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="a1d7e-210">이 내용을 추가하도록 제안하신 `/u/Sheppard_Ra`에게 감사의 말을 전합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="a1d7e-211">형식화된 예외 catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-211">Throwing typed exceptions</span></span>

<span data-ttu-id="a1d7e-212">PowerShell에서 형식화된 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="a1d7e-213">문자열을 사용하여 `throw`를 호출하는 대신</span><span class="sxs-lookup"><span data-stu-id="a1d7e-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="a1d7e-214">다음과 같은 예외 액셀러레이터를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="a1d7e-215">하지만 이 방법을 사용할 때는 메시지를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="a1d7e-216">Throw될 예외의 새 인스턴스를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="a1d7e-217">이 작업을 할 때 메시지는 선택사항입니다. 시스템에는 모든 기본 제공 예외에 대한 기본 메시지가 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="a1d7e-218">PowerShell 5.0 이상을 사용하지 않는다면 예전 방법인 `New-Object`를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="a1d7e-219">형식화된 예외를 사용하면 여러분(또는 다른 사용자)은 이전 섹션에서 설명한 것처럼 형식을 기준으로 예외를 catch할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="a1d7e-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="a1d7e-220">Write-Error -Exception</span></span>

<span data-ttu-id="a1d7e-221">이러한 형식화된 예외를 `Write-Error` 에 추가하고 예외 형식을 기준으로 오류를 `catch`할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="a1d7e-222">`Write-Error`는 다음 예제에서처럼 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="a1d7e-223">그러면 다음과 같이 이를 catch할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="a1d7e-224">.NET 예외 종합 목록</span><span class="sxs-lookup"><span data-stu-id="a1d7e-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="a1d7e-225">이 게시물을 보완하기 위해 [Reddit/r/PowerShell 커뮤니티][]의 도움을 받아 .NET 예외 수백 개를 포함하는 종합 목록을 작성했습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="a1d7e-226">[.NET 예외 종합 목록][]</span><span class="sxs-lookup"><span data-stu-id="a1d7e-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="a1d7e-227">먼저 목록에서 제 상황에 적합할 것 같은 예외를 검색하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="a1d7e-228">여러분은 기본 `System` 네임스페이스에서 예외를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="a1d7e-229">예외는 개체입니다</span><span class="sxs-lookup"><span data-stu-id="a1d7e-229">Exceptions are objects</span></span>

<span data-ttu-id="a1d7e-230">수많은 형식화된 예외를 사용할 때는 예외가 개체라는 사실을 명심해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="a1d7e-231">예외는 저마다 생성자와 속성이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="a1d7e-232">[FileNotFoundException][] 설명서의 `System.IO.FileNotFoundException` 항목을 살펴보면 메시지와 파일 경로를 전달할 수 있음을 알게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="a1d7e-233">그리고 파일 경로를 노출하는 `FileName` 속성도 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="a1d7e-234">다른 생성자와 개체 속성 관련 정보는 [.NET 설명서][]를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="a1d7e-235">예외 다시 throw</span><span class="sxs-lookup"><span data-stu-id="a1d7e-235">Re-throwing an exception</span></span>

<span data-ttu-id="a1d7e-236">`catch` 블록에서 같은 예외를 `throw`하기만 할 생각이라면 예외를 `catch`해선 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="a1d7e-237">발생하면 처리하거나 특정 작업을 수행할 계획을 세운 예외만 `catch`해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="a1d7e-238">예외에 특정 작업을 수행하고 싶지만 다운스트림에서 처리할 수 있도록 예외를 다시 throw해야 할 때도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="a1d7e-239">문제를 발견한 지점 근처에서 메시지를 작성하거나 문제를 기록할 수 있지만, 문제 처리는 스택 위쪽에서 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="a1d7e-240">흥미롭게도 `catch` 내에서 `throw`를 호출하고 현재 예외를 다시 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="a1d7e-241">소스 스크립트나 줄 번호 같은 원래 실행 정보를 유지하기 위해 예외를 다시 throw하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="a1d7e-242">이 시점에서 새 예외를 throw하면 예외가 시작된 위치가 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="a1d7e-243">새 예외 다시 throw</span><span class="sxs-lookup"><span data-stu-id="a1d7e-243">Re-throwing a new exception</span></span>

<span data-ttu-id="a1d7e-244">예외를 catch했지만 다른 예외를 throw하고 싶다면 원래 예외를 새 예외 안에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="a1d7e-245">이렇게 하면 스택 아래에 있는 사람이 이 예외를 `$PSItem.Exception.InnerException`으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="a1d7e-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="a1d7e-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="a1d7e-247">제가 원시 예외에 `throw`를 사용하길 꺼리는 이유는 오류 메시지가 `throw` 문을 가리키며 해당 줄이 문제가 있는 곳이라 표시하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="a1d7e-248">31번째 줄에서 `throw`를 호출했기 때문에 스크립트가 손상되었다고 말하는 오류 메시지는 여러분의 스크립트 사용자에게 표시되면 안 되는 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="a1d7e-249">어떤 유익한 정보도 전달하지 못하죠.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="a1d7e-250">Dexter Dhami가 `ThrowTerminatingError()`를 이용하면 이 문제를 해결할 수 있다고 알려주었습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="a1d7e-251">`ThrowTerminatingError()`가 `Get-Resource`라는 함수 내에서 호출되었다고 한다면, 이 오류 메시지는 적절한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="a1d7e-252">`Get-Resource` 함수가 문제의 원인이라 말하고 있죠?</span><span class="sxs-lookup"><span data-stu-id="a1d7e-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="a1d7e-253">사용자에게 도움이 되는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-253">That tells the user something useful.</span></span>

<span data-ttu-id="a1d7e-254">`$PSItem`은 `ErrorRecord`이기 때문에 `ThrowTerminatingError`를 이 방식으로 이용하여 다시 throw할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="a1d7e-255">이렇게 하면 오류가 발생 한 소스가 Cmdlet으로 변경되고 Cmdlet 사용자가 함수 내부 구조를 볼 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="a1d7e-256">Try를 이용하면 종료 오류를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-256">Try can create terminating errors</span></span>

<span data-ttu-id="a1d7e-257">Kirk Munro는 일부 예외는 `try/catch` 블록 내부에서 실행될 때는 반드시 종료 오류라는 점을 지적합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="a1d7e-258">다음은 그가 알려준 0으로 나누는 런타임 예외를 생성하는 예시입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="a1d7e-259">그런 다음 이런 식으로 호출하면 오류가 생성되고 메시지가 계속 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="a1d7e-260">하지만 `try/catch` 내에 동일한 코드를 배치하면 다른 현상이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="a1d7e-261">오류가 종료 오류가 되며 첫 번째 메시지가 출력되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="a1d7e-262">제가 이 코드를 싫어하는 이유는 함수에 이 코드를 배치했을 때 다른 사용자가 `try/catch`를 사용하면 동작이 달라지기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="a1d7e-263">제가 직접 겪은 적은 없지만 이 문제는 반드시 유념해야 하는 코너 케이스입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="a1d7e-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span><span class="sxs-lookup"><span data-stu-id="a1d7e-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="a1d7e-265">`$PSCmdlet.ThrowTerminatingError()`의 한 가지 특징은 Cmdlet 내에서는 종료 오류를 생성하지만 Cmdlet을 나가면 종료되지 않는 오류로 변한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="a1d7e-266">따라서 함수 호출자가 오류 처리 방법을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="a1d7e-267">`-ErrorAction Stop`을 이용하거나 `try{...}catch{...}` 내에서 호출하면 다시 종료 오류로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="a1d7e-268">공개 함수 템플릿</span><span class="sxs-lookup"><span data-stu-id="a1d7e-268">Public function templates</span></span>

<span data-ttu-id="a1d7e-269">Kirk Munro와의 대화에서 배운 마지막 교훈은 그가 모든 고급 함수의 `begin`, `process`, `end` 블록에 `try{...}catch{...}`를 배치한다는 사실이었습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="a1d7e-270">이러한 일반 catch 블록에서 그는 `$PSCmdlet.ThrowTerminatingError($PSItem)`를 사용하여 한 줄로 함수를 종료하는 모든 예외를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="a1d7e-271">모든 요소가 함수 내의 `try` 문에 있기 때문에 모든 요소가 일관되게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="a1d7e-272">이렇게 하면 생성된 오류의 내부 코드가 표시되지 않는 깔끔한 오류가 최종 사용자가 전달되는 효과도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="a1d7e-273">Trap</span><span class="sxs-lookup"><span data-stu-id="a1d7e-273">Trap</span></span>

<span data-ttu-id="a1d7e-274">예외의 `try/catch` 요소를 중점적으로 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="a1d7e-275">하지만 마무리하기 전에 언급해야 할 레거시 기능이 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="a1d7e-276">`trap`은 관련 범위에서 발생하는 모든 예외를 catch하기 위해 스크립트나 함수에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="a1d7e-277">예외가 발생하면 `trap`에 있는 코드가 실행된 다음 일반 코드가 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="a1d7e-278">여러 예외가 발생하면 trap이 반복해서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="a1d7e-279">개인적으로는 채택하지 않는 방법이지만 모든 예외를 기록한 다음 계속 실행하는 관리 또는 컨트롤러 스크립트도 그만한 가치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="a1d7e-280">맺음말</span><span class="sxs-lookup"><span data-stu-id="a1d7e-280">Closing remarks</span></span>

<span data-ttu-id="a1d7e-281">스크립트에 적절한 예외 처리를 추가하면 안전성을 강화하고, 나아가 이러한 예외를 더 쉽게 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="a1d7e-282">예외 처리의 핵심 개념이기 때문에 `throw`를 집중적으로 설명했죠.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="a1d7e-283">또한 PowerShell을 이용하면 `Write-Error`로 `throw`를 사용하는 모든 상황을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="a1d7e-284">그러니 이 글을 읽은 후에는 `throw`를 사용하지 않아도 될 겁니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="a1d7e-285">오류 처리에 관해서는 여기에 자세히 기록했으니, 지금부터는 `Write-Error -Stop`를 사용하여 코드에서 오류를 생성하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="a1d7e-286">또한 Kirk의 조언을 받아들여 `ThrowTerminatingError`를 모든 함수에 대한 goto 예외 처리기로 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="a1d7e-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[원래 버전]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell 커뮤니티]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[.NET 예외 종합 목록]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET 설명서]: /dotnet/api
[.NET documentation]: /dotnet/api
