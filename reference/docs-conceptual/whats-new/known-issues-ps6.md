---
ms.date: 02/03/2020
keywords: powershell,core
title: PowerShell 6.0의 알려진 문제
description: PowerShell 6의 알려진 문제 또는 제한 사항에 대한 요약 정보입니다.
ms.openlocfilehash: 288bd664d511ebfd18408ce80ec3481333dbba37
ms.sourcegitcommit: f9d855dd73b916559a22e337672dea3fbb11c634
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/07/2020
ms.locfileid: "96833812"
---
# <a name="known-issues-for-powershell-60"></a><span data-ttu-id="e5676-104">PowerShell 6.0의 알려진 문제</span><span class="sxs-lookup"><span data-stu-id="e5676-104">Known Issues for PowerShell 6.0</span></span>

## <a name="known-issues-for-powershell-on-non-windows-platforms"></a><span data-ttu-id="e5676-105">비 Windows 플랫폼에서 PowerShell의 알려진 문제</span><span class="sxs-lookup"><span data-stu-id="e5676-105">Known Issues for PowerShell on Non-Windows Platforms</span></span>

<span data-ttu-id="e5676-106">Linux 및 macOS의 PowerShell 알파 릴리스는 대부분 작동하지만 몇 가지 중요한 제한 사항과 유용성 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-106">Alpha releases of PowerShell on Linux and macOS are mostly functional but do have some significant limitations and usability issues.</span></span> <span data-ttu-id="e5676-107">Linux 및 macOS의 PowerShell 베타 릴리스는 알파 릴리스보다 더 기능이 뛰어나고 안정적이지만, 여전히 일부 기능이 없고 버그를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-107">Beta releases of PowerShell on Linux and macOS are more functional and stable than alpha releases, but still may be lacking some set of features, and can contain bugs.</span></span> <span data-ttu-id="e5676-108">경우에 따라 이러한 문제는 단순히 아직 수정되지 않은 버그입니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-108">In some cases, these issues are simply bugs that haven't been fixed yet.</span></span> <span data-ttu-id="e5676-109">ls, cp 등의 기본 별칭으로 식별되는 기타 경우에서는 Microsoft의 선택과 관련해서 커뮤니티의 피드백에 귀를 기울이고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-109">In other cases (as with the default aliases for ls, cp, etc.), we are looking for feedback from the community regarding the choices we make.</span></span>

<span data-ttu-id="e5676-110">참고: 여러 기본 하위 시스템의 유사성 때문에 Linux 및 macOS의 PowerShell은 기능과 버그 둘 다에서 동일한 완성도를 공유하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-110">Note: Due to the similarities of many underlying subsystems, PowerShell on Linux and macOS tend to share the same level of maturity in both features and bugs.</span></span> <span data-ttu-id="e5676-111">아래에 언급된 경우를 제외하고 이 섹션의 문제는 두 운영 체제에 모두 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-111">Except as noted below, the issues in this section apply to both operating systems.</span></span>

### <a name="case-sensitivity-in-powershell"></a><span data-ttu-id="e5676-112">PowerShell의 대/소문자 구분</span><span class="sxs-lookup"><span data-stu-id="e5676-112">Case-sensitivity in PowerShell</span></span>

<span data-ttu-id="e5676-113">지금까지 PowerShell은 몇 가지 예외를 제외하고 대/소문자를 구분하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-113">Historically, PowerShell has been uniformly case-insensitive, with few exceptions.</span></span> <span data-ttu-id="e5676-114">UNIX 유사 운영 체제에서는 파일 시스템이 대체로 대/소문자를 구분하므로 PowerShell도 파일 시스템의 표준을 준수합니다. 이러한 변화는 명확하거나 명확하지 않은 여러 가지 방식으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-114">On UNIX-like operating systems, the file system is predominantly case-sensitive and PowerShell adheres to the standard of the file system; this is exposed through a number of ways, obvious and non-obvious.</span></span>

#### <a name="directly"></a><span data-ttu-id="e5676-115">직접</span><span class="sxs-lookup"><span data-stu-id="e5676-115">Directly</span></span>

- <span data-ttu-id="e5676-116">PowerShell에서 파일을 지정할 때 올바른 대/소문자를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-116">When specifying a file in PowerShell, the correct case must be used.</span></span>

#### <a name="indirectly"></a><span data-ttu-id="e5676-117">간접적</span><span class="sxs-lookup"><span data-stu-id="e5676-117">Indirectly</span></span>

- <span data-ttu-id="e5676-118">스크립트가 모듈을 로드하려고 할 때 모듈 이름의 대/소문자가 올바르지 않으면 모듈이 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-118">If a script tries to load a module and the module name is not cased correctly, then the module load fails.</span></span> <span data-ttu-id="e5676-119">모듈이 참조된 이름이 실제 파일 이름과 일치하지 않을 경우, 이로 인해 기존 스크립트에서 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-119">This may cause a problem with existing scripts if the name by which the module is referenced doesn't match the actual filename.</span></span>
- <span data-ttu-id="e5676-120">파일 이름 대/소문자가 잘못된 경우 탭 완성이 자동으로 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-120">Tab-completion does not auto-complete if the filename case is wrong.</span></span> <span data-ttu-id="e5676-121">완성할 조각의 대/소문자가 올바르게 지정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-121">The fragment to complete must be cased properly.</span></span> <span data-ttu-id="e5676-122">형식 이름 및 형식 멤버 완성의 경우 완성 기능에서 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-122">(Completion is case-insensitive for type name and type member completions.)</span></span>

### <a name="ps1-file-extensions"></a><span data-ttu-id="e5676-123">.PS1 파일 확장명</span><span class="sxs-lookup"><span data-stu-id="e5676-123">.PS1 File Extensions</span></span>

<span data-ttu-id="e5676-124">PowerShell 스크립트는 `.ps1`로 끝나야 인터프리터가 현재 프로세스에서 스크립트를 로드 및 실행하는 방법을 해석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-124">PowerShell scripts must end in `.ps1` for the interpreter to understand how to load and run them in the current process.</span></span> <span data-ttu-id="e5676-125">현재 프로세스에서 스크립트를 실행하는 것이 PowerShell의 일반적인 예상 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-125">Running scripts in the current process is the expected usual behavior for PowerShell.</span></span> <span data-ttu-id="e5676-126">`.ps1` 확장명이 없는 스크립트에 `#!` 매직 넘버를 추가할 수 있지만, 이로 인해 스크립트가 새 PowerShell 인스턴스에서 실행되므로 개체를 교환할 때 스크립트가 올바르게 작동할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-126">The `#!` magic number may be added to a script that doesn't have a `.ps1` extension, but this causes the script to be run in a new PowerShell instance preventing the script from working properly when interchanging objects.</span></span> <span data-ttu-id="e5676-127">참고: `bash` 또는 다른 셸에서 PowerShell 스크립트를 실행할 때는 적합한 동작일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-127">(Note: this may be the desirable behavior when executing a PowerShell script from `bash` or another shell.)</span></span>

### <a name="missing-command-aliases"></a><span data-ttu-id="e5676-128">명령 별칭 누락</span><span class="sxs-lookup"><span data-stu-id="e5676-128">Missing command aliases</span></span>

<span data-ttu-id="e5676-129">Linux/macOS에서는 기본 명령의 “편리한 별칭”인 `ls`, `cp`, `mv`, `rm`, `cat`, `man`, `mount`, `ps`가 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-129">On Linux/macOS, the "convenience aliases" for the basic commands `ls`, `cp`, `mv`, `rm`, `cat`, `man`, `mount`, `ps` have been removed.</span></span> <span data-ttu-id="e5676-130">Windows의 PowerShell에서는 사용자 편의를 위해 Linux 명령 이름에 매핑되는 별칭 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-130">On Windows, PowerShell provides a set of aliases that map to Linux command names for user convenience.</span></span> <span data-ttu-id="e5676-131">이러한 별칭이 Linux/macOS 배포의 기본 PowerShell에서 제거되었으므로, 경로를 지정하지 않고 네이티브 실행 파일을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-131">These aliases have been removed from the default PowerShell on Linux/macOS distributions, allowing the native executable to be run without specifying a path.</span></span>

<span data-ttu-id="e5676-132">이 변화에는 장/단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-132">There are pros and cons to doing this.</span></span> <span data-ttu-id="e5676-133">별칭을 제거할 경우, 네이티브 명령 환경이 PowerShell 사용자에게 노출되지만, 네이티브 명령은 개체 대신 문자열을 반환하기 때문에 셸의 기능이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-133">Removing the aliases exposes the native command experience to the PowerShell user, but reduces functionality in the shell because the native commands return strings instead of objects.</span></span>

> [!NOTE]
> <span data-ttu-id="e5676-134">PowerShell 팀이 원하는 피드백은 바로 이 영역에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-134">This is an area where the PowerShell team is looking for feedback.</span></span> <span data-ttu-id="e5676-135">선호하는 해결 방법은 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="e5676-135">What is the preferred solution?</span></span>
> <span data-ttu-id="e5676-136">현재 상태대로 유지하는 것이 나을까요, 아니면 편리한 별칭을 다시 추가하는 것이 나을까요?</span><span class="sxs-lookup"><span data-stu-id="e5676-136">Should we leave it as is or add the convenience aliases back?</span></span> <span data-ttu-id="e5676-137">[문제 #929](https://github.com/PowerShell/PowerShell/issues/929)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e5676-137">See [Issue #929](https://github.com/PowerShell/PowerShell/issues/929).</span></span>

### <a name="missing-wildcard-globbing-support"></a><span data-ttu-id="e5676-138">와일드카드 지원 누락</span><span class="sxs-lookup"><span data-stu-id="e5676-138">Missing Wildcard (globbing) Support</span></span>

<span data-ttu-id="e5676-139">현재, PowerShell은 Windows의 기본 제공 cmdlet 및 Linux의 cmdlet과 외부 명령 또는 이진에 대해서만 와일드카드 확장을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-139">Currently, PowerShell only does wildcard expansion (globbing) for built-in cmdlets on Windows, and for external commands or binaries as well as cmdlets on Linux.</span></span> <span data-ttu-id="e5676-140">따라서 `ls
*.txt`와 같은 명령은 별표가 파일 이름과 일치하도록 확장되지 않으므로 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-140">This means that a command like `ls
*.txt` fails because the asterisk is not expanded to match filenames.</span></span> <span data-ttu-id="e5676-141">`ls (gci *.txt | % name)` 또는 더 간단하게 `ls`에 해당하는 PowerShell 기본 제공 구문을 사용하여 `gci *.txt`를 수행하면 이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-141">You can work around this by doing `ls (gci *.txt | % name)` or, more simply, `gci *.txt` using the PowerShell built-in equivalent to `ls`.</span></span>

<span data-ttu-id="e5676-142">Linux/macOS의 와일드카드 환경을 개선하는 방법에 대한 피드백을 제공하려면 [#954](https://github.com/PowerShell/PowerShell/issues/954)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e5676-142">See [#954](https://github.com/PowerShell/PowerShell/issues/954) to give us feedback on how to improve the globbing experience on Linux/macOS.</span></span>

### <a name="net-framework-vs-net-core-framework"></a><span data-ttu-id="e5676-143">.NET Framework 및 .NET Core Framework</span><span class="sxs-lookup"><span data-stu-id="e5676-143">.NET Framework vs .NET Core Framework</span></span>

<span data-ttu-id="e5676-144">Linux/macOS의 PowerShell은 Microsoft Windows의 전체 .NET Framework 하위 집합인 .NET Core를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-144">PowerShell on Linux/macOS uses .NET Core which is a subset of the full .NET Framework on Microsoft Windows.</span></span> <span data-ttu-id="e5676-145">PowerShell을 통해 기본 프레임워크 형식, 메서드 등에 직접 액세스하기 때문에 이러한 차이는 중요합니다. 그 결과로, Windows에서 실행되는 스크립트가 프레임워크의 차이로 인해 비 Windows 플랫폼에서는 실행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-145">This is significant because PowerShell provides direct access to the underlying framework types, methods, etc. As a result, scripts that run on Windows may not run on non-Windows platforms because of the differences in the frameworks.</span></span> <span data-ttu-id="e5676-146">.NET Core Framework에 대한 자세한 내용은 [dotnetfoundation](https://dotnetfoundation.org/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e5676-146">For more information about .NET Core Framework, see [dotnetfoundation.org](https://dotnetfoundation.org/).</span></span>

<span data-ttu-id="e5676-147">[.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)이 도입되면서, .NET Core 2.0에서는 전체 .NET Framework에 있는 기존의 여러 형식과 메서드를 다시 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-147">With the advent of [.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/introducing-net-standard/), .NET Core 2.0 brings back many of the traditional types and methods present in the full .NET Framework.</span></span> <span data-ttu-id="e5676-148">따라서 PowerShell Core에서 기존의 여러 Windows PowerShell 모듈을 수정 없이 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-148">This means that PowerShell Core can load many traditional Windows PowerShell modules without modification.</span></span> <span data-ttu-id="e5676-149">[여기](https://github.com/PowerShell/PowerShell/projects/4)에서 .NET Standard 2.0 관련 작업을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-149">You can follow our .NET Standard 2.0 related work [here](https://github.com/PowerShell/PowerShell/projects/4).</span></span>

### <a name="redirection-issues"></a><span data-ttu-id="e5676-150">리디렉션 문제</span><span class="sxs-lookup"><span data-stu-id="e5676-150">Redirection Issues</span></span>

<span data-ttu-id="e5676-151">입력 리디렉션은 모든 플랫폼의 PowerShell에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-151">Input redirection is not supported in PowerShell on any platform.</span></span>
[<span data-ttu-id="e5676-152">문제 #1629</span><span class="sxs-lookup"><span data-stu-id="e5676-152">Issue #1629</span></span>](https://github.com/PowerShell/PowerShell/issues/1629)

<span data-ttu-id="e5676-153">`Get-Content`를 사용하여 파일 내용을 파이프라인에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-153">Use `Get-Content` to write the contents of a file into the pipeline.</span></span>

<span data-ttu-id="e5676-154">기본 UTF-8 인코딩을 사용하는 경우 리디렉션된 출력에는 유니코드 BOM(바이트 순서 표시)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-154">Redirected output contains the Unicode byte order mark (BOM) when the default UTF-8 encoding is used.</span></span> <span data-ttu-id="e5676-155">BOM을 예상하지 않는 유틸리티를 사용하거나 파일에 추가하는 경우 BOM으로 인해 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-155">The BOM causes problems when working with utilities that do not expect it or when appending to a file.</span></span> <span data-ttu-id="e5676-156">BOM이 없는 ASCII 텍스트를 작성하려면 `-Encoding Ascii`을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-156">Use `-Encoding Ascii` to write ASCII text, which does not have a BOM.</span></span>

> [!Note]
> <span data-ttu-id="e5676-157">모든 플랫폼에 걸쳐 PowerShell Core의 인코딩 환경 개선에 대한 피드백을 제공하려면 [RFC0020](https://github.com/PowerShell/PowerShell-RFC/issues/71)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e5676-157">see [RFC0020](https://github.com/PowerShell/PowerShell-RFC/issues/71) to give us feedback on improving the encoding experience for PowerShell Core across all platforms.</span></span> <span data-ttu-id="e5676-158">BOM 없이 UTF-8을 지원하기 위해 노력하고 있으며 여러 플랫폼에서 다양한 cmdlet의 인코딩 기본값이 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-158">We are working to support UTF-8 without a BOM and potentially changing the encoding defaults for various cmdlets across platforms.</span></span>

### <a name="job-control"></a><span data-ttu-id="e5676-159">작업 제어</span><span class="sxs-lookup"><span data-stu-id="e5676-159">Job Control</span></span>

<span data-ttu-id="e5676-160">Linux/macOS의 PowerShell에는 작업 제어 지원이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-160">There is no job-control support in PowerShell on Linux/macOS.</span></span>
<span data-ttu-id="e5676-161">`fg` 및 `bg` 명령을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-161">The `fg` and `bg` commands are not available.</span></span>

<span data-ttu-id="e5676-162">작업 제어가 지원될 때까지, 모든 플랫폼에서 작동하는 [PowerShell 작업](/powershell/module/microsoft.powershell.core/about/about_jobs)을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-162">For the time being, you can use [PowerShell jobs](/powershell/module/microsoft.powershell.core/about/about_jobs) which do work across all platforms.</span></span>

### <a name="remoting-support"></a><span data-ttu-id="e5676-163">원격 지원</span><span class="sxs-lookup"><span data-stu-id="e5676-163">Remoting Support</span></span>

<span data-ttu-id="e5676-164">현재, PowerShell Core는 macOS 및 Linux의 기본 인증과 Linux의 NTLM 기반 인증을 사용하여 WSMan을 통한 PowerShell 원격(PSRP)을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-164">Currently, PowerShell Core supports PowerShell Remoting (PSRP) over WSMan with Basic authentication on macOS and Linux, and with NTLM-based authentication on Linux.</span></span> <span data-ttu-id="e5676-165">Kerberos 기반 인증은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-165">(Kerberos-based authentication is not supported.)</span></span>

<span data-ttu-id="e5676-166">WSMan 기반 원격 작업은 [psl-omi-provider](https://github.com/PowerShell/psl-omi-provider) 리포지토리에서 수행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-166">The work for WSMan-based remoting is being done in the [psl-omi-provider](https://github.com/PowerShell/psl-omi-provider) repo.</span></span>

<span data-ttu-id="e5676-167">PowerShell Core는 모든 플랫폼(Windows, macOS 및 Linux)에서 SSH를 통한 PowerShell 원격(PSRP)도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-167">PowerShell Core also supports PowerShell Remoting (PSRP) over SSH on all platforms (Windows, macOS, and Linux).</span></span> <span data-ttu-id="e5676-168">프로덕션에서 현재 지원되지는 않지만, [여기](/powershell/scripting/learn/remoting/SSH-Remoting-in-PowerShell-Core)에서 설정 방법을 자세히 알아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-168">While this is not currently supported in production, you can learn more about setting this up [here](/powershell/scripting/learn/remoting/SSH-Remoting-in-PowerShell-Core).</span></span>

### <a name="just-enough-administration-jea-support"></a><span data-ttu-id="e5676-169">JEA(Just-Enough-Administration) 지원</span><span class="sxs-lookup"><span data-stu-id="e5676-169">Just-Enough-Administration (JEA) Support</span></span>

<span data-ttu-id="e5676-170">제한된 관리(JEA) 원격 엔드포인트를 만드는 기능은 Linux/macOS의 PowerShell에서 현재 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-170">The ability to create constrained administration (JEA) remoting endpoints is not currently available in PowerShell on Linux/macOS.</span></span> <span data-ttu-id="e5676-171">이 기능은 현재 6.0의 범위에 없으며, 상당한 디자인 작업이 필요하므로 6.0 이후에 고려될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-171">This feature is currently not in scope for 6.0 and something we will consider post 6.0 as it requires significant design work.</span></span>

### <a name="sudo-exec-and-powershell"></a><span data-ttu-id="e5676-172">`sudo`, `exec` 및 PowerShell</span><span class="sxs-lookup"><span data-stu-id="e5676-172">`sudo`, `exec`, and PowerShell</span></span>

<span data-ttu-id="e5676-173">PowerShell은 대부분의 명령(예: Python 또는 Ruby)을 메모리에서 실행하므로 PowerShell 기본 제공 기능에서 바로 sudo를 사용할 수 없습니다. 물론, sudo에서 `pwsh`을 실행할 수는 있습니다. sudo를 사용하여 PowerShell 내에서 PowerShell cmdlet을 실행해야 하는 경우(예: `sudo Set-Date 8/18/2016`), `sudo pwsh Set-Date 8/18/2016`을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-173">Because PowerShell runs most commands in memory (like Python or Ruby), you can't use sudo directly with PowerShell built-ins. (You can, of course, run `pwsh` from sudo.) If it is necessary to run a PowerShell cmdlet from within PowerShell with sudo, for example, `sudo Set-Date 8/18/2016`, then you would do `sudo pwsh Set-Date 8/18/2016`.</span></span> <span data-ttu-id="e5676-174">마찬가지로, PowerShell 기본 제공 기능을 바로 실행할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-174">Likewise, you can't exec a PowerShell built-in directly.</span></span> <span data-ttu-id="e5676-175">대신, `exec pwsh item_to_exec`를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-175">Instead you would have to do `exec pwsh item_to_exec`.</span></span>

<span data-ttu-id="e5676-176">이 문제는 [#3232](https://github.com/PowerShell/PowerShell/issues/3232)의 일부로 추적되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-176">This issue is being tracked as part of [#3232](https://github.com/PowerShell/PowerShell/issues/3232).</span></span>

### <a name="missing-cmdlets"></a><span data-ttu-id="e5676-177">cmdlet 누락</span><span class="sxs-lookup"><span data-stu-id="e5676-177">Missing Cmdlets</span></span>

<span data-ttu-id="e5676-178">PowerShell에서 일반적으로 사용할 수 있는 많은 명령(cmdlet)이 Linux/macOS에서는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-178">A large number of the commands (cmdlets) normally available in PowerShell are not available on Linux/macOS.</span></span> <span data-ttu-id="e5676-179">대부분의 경우 이러한 명령은 해당 플랫폼에서 의미가 없습니다(예: 레지스트리 등의 Windows 특정 기능).</span><span class="sxs-lookup"><span data-stu-id="e5676-179">In many cases, these commands make no sense on these platforms (e.g. Windows-specific features like the registry).</span></span> <span data-ttu-id="e5676-180">서비스 제어 명령(Get/Start/Stop-Service) 등의 기타 명령은 있지만 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-180">Other commands like the service control commands (Get/Start/Stop-Service) are present, but not functional.</span></span> <span data-ttu-id="e5676-181">향후 릴리스에서는 손상된 cmdlet을 수정하고 시간에 따라 새 cmdlet을 추가하여 이러한 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-181">Future releases may correct these problems by fixing the broken cmdlets and adding new ones over time.</span></span>

### <a name="command-availability"></a><span data-ttu-id="e5676-182">명령 가용성</span><span class="sxs-lookup"><span data-stu-id="e5676-182">Command Availability</span></span>

<span data-ttu-id="e5676-183">다음 표에는 Linux/macOS의 PowerShell에서 작동하지 않는 것으로 알려진 명령이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-183">The following table lists commands that are known not to work in PowerShell on Linux/macOS.</span></span>

|<span data-ttu-id="e5676-184">명령</span><span class="sxs-lookup"><span data-stu-id="e5676-184">Commands</span></span>|<span data-ttu-id="e5676-185">작동 상태</span><span class="sxs-lookup"><span data-stu-id="e5676-185">Operational State</span></span>|<span data-ttu-id="e5676-186">참고</span><span class="sxs-lookup"><span data-stu-id="e5676-186">Notes</span></span>|
|--------|-----------------|-----|
|<span data-ttu-id="e5676-187">`Get-Service`, `New-Service`, `Restart-Service`, `Resume-Service`, `Set-Service`, `Start-Service`, `Stop-Service`, `Suspend-Service`</span><span class="sxs-lookup"><span data-stu-id="e5676-187">`Get-Service`, `New-Service`, `Restart-Service`, `Resume-Service`, `Set-Service`, `Start-Service`, `Stop-Service`, `Suspend-Service`</span></span>|<span data-ttu-id="e5676-188">사용할 수 없음.</span><span class="sxs-lookup"><span data-stu-id="e5676-188">Not Available.</span></span>|<span data-ttu-id="e5676-189">이러한 명령은 인식되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-189">These commands are not recognized.</span></span> <span data-ttu-id="e5676-190">이 문제는 향후 릴리스에서 해결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-190">This should be fixed in a future release.</span></span>|
|<span data-ttu-id="e5676-191">`Get-Acl`, `Get-AuthenticodeSignature`, `Get-CmsMessage`, `New-FileCatalog`, `Protect-CmsMessage`, `Set-Acl`, `Set-AuthenticodeSignature`, `Test-FileCatalog`, `Unprotect-CmsMessage`</span><span class="sxs-lookup"><span data-stu-id="e5676-191">`Get-Acl`, `Get-AuthenticodeSignature`, `Get-CmsMessage`, `New-FileCatalog`, `Protect-CmsMessage`, `Set-Acl`, `Set-AuthenticodeSignature`, `Test-FileCatalog`, `Unprotect-CmsMessage`</span></span>|<span data-ttu-id="e5676-192">사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-192">Not available.</span></span>|<span data-ttu-id="e5676-193">이러한 명령은 인식되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-193">These commands are not recognized.</span></span> <span data-ttu-id="e5676-194">이 문제는 향후 릴리스에서 해결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-194">This should be fixed in a future release.</span></span>|
|`Wait-Process`|<span data-ttu-id="e5676-195">사용 가능하지만 제대로 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-195">Available, doesn't work properly.</span></span> |<span data-ttu-id="e5676-196">예를 들어, `Start-Process gvim -PassThru | Wait-Process`는 작동하지 않고, 프로세스를 기다리지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-196">For example `Start-Process gvim -PassThru | Wait-Process` doesn't work; it fails to wait for the process.</span></span>|
|<span data-ttu-id="e5676-197">`Connect-PSSession`, `Disable-PSRemoting`, `Disable-PSSessionConfiguration`, `Disconnect-PSSession`, `Enable-PSRemoting`, `Enable-PSSessionConfiguration`, `Get-PSSessionCapability`, `Get-PSSessionConfiguration`, `New-PSSessionConfigurationFile`, `Receive-PSSession`, `Register-PSSessionConfiguration`, `Set-PSSessionConfiguration`, `Test-PSSessionConfigurationFile`, `Unregister-PSSessionConfiguration`</span><span class="sxs-lookup"><span data-stu-id="e5676-197">`Connect-PSSession`, `Disable-PSRemoting`, `Disable-PSSessionConfiguration`, `Disconnect-PSSession`, `Enable-PSRemoting`, `Enable-PSSessionConfiguration`, `Get-PSSessionCapability`, `Get-PSSessionConfiguration`, `New-PSSessionConfigurationFile`, `Receive-PSSession`, `Register-PSSessionConfiguration`, `Set-PSSessionConfiguration`, `Test-PSSessionConfigurationFile`, `Unregister-PSSessionConfiguration`</span></span>|<span data-ttu-id="e5676-198">사용할 수 없음.</span><span class="sxs-lookup"><span data-stu-id="e5676-198">Not Available.</span></span>|<span data-ttu-id="e5676-199">이러한 명령은 인식되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-199">These commands are not recognized.</span></span> <span data-ttu-id="e5676-200">이 문제는 향후 릴리스에서 해결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-200">This should be fixed in a future release.</span></span>|
|<span data-ttu-id="e5676-201">`Get-Event`, `New-Event`, `Register-EngineEvent`, `Remove-Event`, `Unregister-Event`</span><span class="sxs-lookup"><span data-stu-id="e5676-201">`Get-Event`, `New-Event`, `Register-EngineEvent`, `Remove-Event`, `Unregister-Event`</span></span>|<span data-ttu-id="e5676-202">사용 가능하지만, 사용할 수 있는 이벤트 원본이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-202">Available but no event sources are available.</span></span>|<span data-ttu-id="e5676-203">PowerShell 이벤트 명령이 있지만, 명령과 함께 사용되는 대부분의 이벤트 원본(예: System.Timers.Timer)은 Linux에서 사용할 수 없으므로 알파 릴리스에서는 명령이 아무 소용도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-203">The PowerShell eventing commands are present but most of the event sources used with the commands (such as System.Timers.Timer) are not available on Linux making the commands useless in the Alpha release.</span></span>|
|`Set-ExecutionPolicy`|<span data-ttu-id="e5676-204">사용 가능하지만 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-204">Available but doesn't work.</span></span>|<span data-ttu-id="e5676-205">이 플랫폼에서 지원되지 않는다는 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-205">Returns a message saying not supported on this platform.</span></span> <span data-ttu-id="e5676-206">실행 정책은 사용자가 값비싼 실수를 하지 않도록 방지하는 사용자 중심 “안전 벨트”입니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-206">Execution policy is a user-focused "safety belt" that helps prevent the user from making expensive mistakes.</span></span> <span data-ttu-id="e5676-207">보안 경계가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-207">It is not a security boundary.</span></span>|
|<span data-ttu-id="e5676-208">`New-PSSessionOption`, `New-PSTransportOption`</span><span class="sxs-lookup"><span data-stu-id="e5676-208">`New-PSSessionOption`, `New-PSTransportOption`</span></span>|<span data-ttu-id="e5676-209">사용 가능하지만 `New-PSSession`은 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-209">Available but `New-PSSession` doesn't work.</span></span>|<span data-ttu-id="e5676-210">`New-PSSessionOption` 및 `New-PSTransportOption`은 현재 `New-PSSession`이 작동하는 상태에서 작동하는지 확인되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="e5676-210">`New-PSSessionOption` and `New-PSTransportOption` are not currently verified to work now that `New-PSSession` works.</span></span>|
