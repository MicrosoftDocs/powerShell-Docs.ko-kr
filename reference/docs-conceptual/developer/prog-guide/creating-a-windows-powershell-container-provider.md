---
title: Windows PowerShell 컨테이너 공급자 만들기
ms.date: 09/13/2016
ms.topic: article
ms.openlocfilehash: eec92d526ad78d2351eef6679eaa0df19900715b
ms.sourcegitcommit: 7f2479edd329dfdc55726afff7019d45e45f9156
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/08/2020
ms.locfileid: "80978494"
---
# <a name="creating-a-windows-powershell-container-provider"></a><span data-ttu-id="a7f48-102">Windows PowerShell 컨테이너 공급자 만들기</span><span class="sxs-lookup"><span data-stu-id="a7f48-102">Creating a Windows PowerShell Container Provider</span></span>

<span data-ttu-id="a7f48-103">이 항목에서는 다중 계층 데이터 저장소에서 작동할 수 있는 Windows PowerShell 공급자를 만드는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-103">This topic describes how to create a Windows PowerShell provider that can work on multi-layer data stores.</span></span> <span data-ttu-id="a7f48-104">이러한 유형의 데이터 저장소의 경우 저장소의 최상위 수준에 루트 항목이 포함 되 고 각 후속 수준은 자식 항목의 노드 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-104">For this type of data store, the top level of the store contains the root items and each subsequent level is referred to as a node of child items.</span></span> <span data-ttu-id="a7f48-105">사용자는 이러한 자식 노드에 대해 작업을 수행할 수 있으므로 데이터 저장소를 통해 계층적으로 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-105">By allowing the user to work on these child nodes, a user can interact hierarchically through the data store.</span></span>

<span data-ttu-id="a7f48-106">다중 수준 데이터 저장소에서 작업할 수 있는 공급자를 Windows PowerShell 컨테이너 공급자 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-106">Providers that can work on multi-level data stores are referred to as Windows PowerShell container providers.</span></span> <span data-ttu-id="a7f48-107">그러나 Windows PowerShell 컨테이너 공급자는 항목을 포함 하는 컨테이너 (중첩 된 컨테이너 없음)가 하나 있는 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-107">However, be aware that a Windows PowerShell container provider can be used only when there is one container (no nested containers) with items in it.</span></span> <span data-ttu-id="a7f48-108">중첩 된 컨테이너가 있는 경우 Windows PowerShell 탐색 공급자를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-108">If there are nested containers, then you must implement a Windows PowerShell navigation provider.</span></span> <span data-ttu-id="a7f48-109">Windows PowerShell 탐색 공급자를 구현 하는 방법에 대 한 자세한 내용은 [Windows Powershell 탐색 공급자 만들기](./creating-a-windows-powershell-navigation-provider.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-109">For more information about implementing Windows PowerShell navigation provider, see [Creating a Windows PowerShell Navigation Provider](./creating-a-windows-powershell-navigation-provider.md).</span></span>

> [!NOTE]
> <span data-ttu-id="a7f48-110">Windows Vista 및 .NET Framework C# 3.0 런타임 구성 요소에 대 한 Microsoft Windows 소프트웨어 개발 키트를 사용 하 여이 공급자에 대 한 원본 파일 (AccessDBSampleProvider04.cs)을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-110">You can download the C# source file (AccessDBSampleProvider04.cs) for this provider using the Microsoft Windows Software Development Kit for Windows Vista and .NET Framework 3.0 Runtime Components.</span></span> <span data-ttu-id="a7f48-111">다운로드 지침은 [Windows powershell을 설치 하 고 Windows POWERSHELL SDK를 다운로드 하는 방법](/powershell/scripting/developer/installing-the-windows-powershell-sdk)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-111">For download instructions, see [How to Install Windows PowerShell and Download the Windows PowerShell SDK](/powershell/scripting/developer/installing-the-windows-powershell-sdk).</span></span>
> <span data-ttu-id="a7f48-112">다운로드 된 원본 파일은 **\<PowerShell Samples >** 디렉터리에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-112">The downloaded source files are available in the **\<PowerShell Samples>** directory.</span></span> <span data-ttu-id="a7f48-113">다른 Windows PowerShell 공급자 구현에 대 한 자세한 내용은 [Windows Powershell 공급자 디자인](./designing-your-windows-powershell-provider.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-113">For more information about other Windows PowerShell provider implementations, see [Designing Your Windows PowerShell Provider](./designing-your-windows-powershell-provider.md).</span></span>

<span data-ttu-id="a7f48-114">여기에 설명 된 Windows PowerShell 컨테이너 공급자는 데이터베이스의 테이블 및 행이 컨테이너의 항목으로 정의 된 단일 컨테이너로 데이터베이스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-114">The Windows PowerShell container provider described here defines the database as its single container, with the tables and rows of the database defined as items of the container.</span></span>

> [!CAUTION]
> <span data-ttu-id="a7f48-115">이 설계에서는 이름이 ID가 인 필드가 있는 데이터베이스를 가정 하 고 해당 필드의 형식은가 중 정수 라는 것을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-115">Be aware that this design assumes a database that has a field with the name ID, and that the type of the field is LongInteger.</span></span>

## <a name="defining-a-windows-powershell-container-provider-class"></a><span data-ttu-id="a7f48-116">Windows PowerShell 컨테이너 공급자 클래스 정의</span><span class="sxs-lookup"><span data-stu-id="a7f48-116">Defining a Windows PowerShell Container Provider Class</span></span>

<span data-ttu-id="a7f48-117">Windows PowerShell 컨테이너 공급자는 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) 기본 클래스에서 파생 되는 .net 클래스를 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-117">A Windows PowerShell container provider must define a .NET class that derives from the [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) base class.</span></span> <span data-ttu-id="a7f48-118">이 섹션에서 설명 하는 Windows PowerShell 컨테이너 공급자에 대 한 클래스 정의는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-118">Here is the class definition for the Windows PowerShell container provider described in this section.</span></span>

```csharp
[CmdletProvider("AccessDB", ProviderCapabilities.None)]
public class AccessDBProvider : ContainerCmdletProvider
```

:::code language="csharp" source="~/../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs" range="34-35":::

<span data-ttu-id="a7f48-119">이 클래스 정의에서 [Cmdletproviderattribute](/dotnet/api/System.Management.Automation.Provider.CmdletProviderAttribute) 특성에는 두 개의 매개 변수가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-119">Notice that in this class definition, the [System.Management.Automation.Provider.Cmdletproviderattribute](/dotnet/api/System.Management.Automation.Provider.CmdletProviderAttribute) attribute includes two parameters.</span></span> <span data-ttu-id="a7f48-120">첫 번째 매개 변수는 Windows PowerShell에서 사용 되는 공급자에 대 한 친숙 한 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-120">The first parameter specifies a user-friendly name for the provider that is used by Windows PowerShell.</span></span> <span data-ttu-id="a7f48-121">두 번째 매개 변수는 명령을 처리 하는 동안 공급자가 Windows PowerShell 런타임에 노출 하는 Windows PowerShell 특정 기능을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-121">The second parameter specifies the Windows PowerShell specific capabilities that the provider exposes to the Windows PowerShell runtime during command processing.</span></span> <span data-ttu-id="a7f48-122">이 공급자의 경우 추가 되는 Windows PowerShell 관련 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-122">For this provider, there are no Windows PowerShell specific capabilities that are added.</span></span>

## <a name="defining-base-functionality"></a><span data-ttu-id="a7f48-123">기본 기능 정의</span><span class="sxs-lookup"><span data-stu-id="a7f48-123">Defining Base Functionality</span></span>

<span data-ttu-id="a7f48-124">[Windows PowerShell 공급자 디자인](./designing-your-windows-powershell-provider.md)에 설명 된 대로 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) 클래스는 다른 공급자 기능을 제공 하는 다른 여러 클래스에서 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-124">As described in [Designing Your Windows PowerShell Provider](./designing-your-windows-powershell-provider.md), the [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) class derives from several other classes that provided different provider functionality.</span></span> <span data-ttu-id="a7f48-125">따라서 Windows PowerShell 컨테이너 공급자는 해당 클래스에서 제공 하는 기능을 모두 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-125">A Windows PowerShell container provider, therefore, needs to define all of the functionality provided by those classes.</span></span>

<span data-ttu-id="a7f48-126">세션 관련 초기화 정보를 추가 하 고 공급자가 사용 하는 리소스를 해제 하는 기능을 구현 하려면 [기본 Windows PowerShell 공급자 만들기](./creating-a-basic-windows-powershell-provider.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-126">To implement functionality for adding session-specific initialization information and for releasing resources that are used by the provider, see [Creating a Basic Windows PowerShell Provider](./creating-a-basic-windows-powershell-provider.md).</span></span>
<span data-ttu-id="a7f48-127">그러나 여기에 설명 된 공급자를 비롯 한 대부분의 공급자는 Windows PowerShell에서 제공 하는이 기능의 기본 구현을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-127">However, most providers (including the provider described here) can use the default implementation of this functionality that is provided by Windows PowerShell.</span></span>

<span data-ttu-id="a7f48-128">데이터 저장소에 대 한 액세스 권한을 얻으려면 공급자는 [system.object](/dotnet/api/System.Management.Automation.Provider.DriveCmdletProvider) 의 메서드를 구현 해야 합니다 (예를 들어, 공급자는 클래스의 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-128">To get access to the data store, the provider must implement the methods of the [System.Management.Automation.Provider.Drivecmdletprovider](/dotnet/api/System.Management.Automation.Provider.DriveCmdletProvider) base class.</span></span> <span data-ttu-id="a7f48-129">이러한 메서드를 구현 하는 방법에 대 한 자세한 내용은 [Windows PowerShell 드라이브 공급자 만들기](./creating-a-windows-powershell-drive-provider.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-129">For more information about implementing these methods, see [Creating an Windows PowerShell Drive Provider](./creating-a-windows-powershell-drive-provider.md).</span></span>

<span data-ttu-id="a7f48-130">항목 가져오기, 설정 및 지우기와 같은 데이터 저장소의 항목을 조작 하려면 공급자는 [system.object](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider) 에서 제공 하는 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-130">To manipulate the items of a data store, such as getting, setting, and clearing items, the provider must implement the methods provided by the [System.Management.Automation.Provider.Itemcmdletprovider](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider) base class.</span></span> <span data-ttu-id="a7f48-131">이러한 메서드를 구현 하는 방법에 대 한 자세한 내용은 [Windows PowerShell 항목 공급자 만들기](./creating-a-windows-powershell-item-provider.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-131">For more information about implementing these methods, see [Creating an Windows PowerShell Item Provider](./creating-a-windows-powershell-item-provider.md).</span></span>

## <a name="retrieving-child-items"></a><span data-ttu-id="a7f48-132">자식 항목 검색</span><span class="sxs-lookup"><span data-stu-id="a7f48-132">Retrieving Child Items</span></span>

<span data-ttu-id="a7f48-133">자식 항목을 검색 하려면 Windows PowerShell 컨테이너 공급자가 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 재정의 하 여 `Get-ChildItem` cmdlet의 호출을 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-133">To retrieve a child item, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method to support calls from the `Get-ChildItem` cmdlet.</span></span> <span data-ttu-id="a7f48-134">이 메서드는 데이터 저장소에서 자식 항목을 검색 하 여 파이프라인에 개체로 씁니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-134">This method retrieves child items from the data store and writes them to the pipeline as objects.</span></span> <span data-ttu-id="a7f48-135">Cmdlet의 `recurse` 매개 변수가 지정 된 경우 메서드는의 수준에 관계 없이 모든 자식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-135">If the `recurse` parameter of the cmdlet is specified, the method retrieves all children regardless of what level they are at.</span></span> <span data-ttu-id="a7f48-136">`recurse` 매개 변수를 지정 하지 않으면 메서드는 단일 수준의 자식만 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-136">If the `recurse` parameter is not specified, the method retrieves only a single level of children.</span></span>

<span data-ttu-id="a7f48-137">이 공급자에 대 한 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드의 구현은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-137">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method for this provider.</span></span> <span data-ttu-id="a7f48-138">이 메서드는 경로가 Access 데이터베이스를 나타내는 경우 모든 데이터베이스 테이블의 자식 항목을 검색 하 고 경로가 데이터 테이블을 나타내는 경우 해당 테이블의 행에서 자식 항목을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-138">Notice that this method retrieves the child items in all database tables when the path indicates the Access database, and retrieves the child items from the rows of that table if the path indicates a data table.</span></span>

```csharp
protected override void GetChildItems(string path, bool recurse)
{
    // If path represented is a drive then the children in the path are
    // tables. Hence all tables in the drive represented will have to be
    // returned
    if (PathIsDrive(path))
    {
        foreach (DatabaseTableInfo table in GetTables())
        {
            WriteItemObject(table, path, true);

            // if the specified item exists and recurse has been set then
            // all child items within it have to be obtained as well
            if (ItemExists(path) && recurse)
            {
                GetChildItems(path + pathSeparator + table.Name, recurse);
            }
        } // foreach (DatabaseTableInfo...
    } // if (PathIsDrive...
    else
    {
        // Get the table name, row number and type of path from the
        // path specified
        string tableName;
        int rowNumber;

        PathType type = GetNamesFromPath(path, out tableName, out rowNumber);

        if (type == PathType.Table)
        {
            // Obtain all the rows within the table
            foreach (DatabaseRowInfo row in GetRows(tableName))
            {
                WriteItemObject(row, path + pathSeparator + row.RowNumber,
                        false);
            } // foreach (DatabaseRowInfo...
        }
        else if (type == PathType.Row)
        {
            // In this case the user has directly specified a row, hence
            // just give that particular row
            DatabaseRowInfo row = GetRow(tableName, rowNumber);
            WriteItemObject(row, path + pathSeparator + row.RowNumber,
                        false);
        }
        else
        {
            // In this case, the path specified is not valid
            ThrowTerminatingInvalidPathException(path);
        }
    } // else
} // GetChildItems
```

:::code language="csharp" source="~/../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs" range="311-362":::

#### <a name="things-to-remember-about-implementing-getchilditems"></a><span data-ttu-id="a7f48-139">GetChildItems 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-139">Things to Remember About Implementing GetChildItems</span></span>

<span data-ttu-id="a7f48-140">다음 조건은 Containercmdletprovider의 구현에 적용 될 수 있습니다. [Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span><span class="sxs-lookup"><span data-stu-id="a7f48-140">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span></span>

- <span data-ttu-id="a7f48-141">공급자 클래스를 정의 하는 경우 Windows PowerShell 컨테이너 공급자가 ExpandWildcards, Filter, Include 또는 Exclude의 공급자 기능을 [system.object](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) 열거형에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-141">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="a7f48-142">이러한 경우 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 구현 하면 메서드에 전달 된 경로가 지정 된 기능의 요구 사항을 충족 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-142">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="a7f48-143">이 작업을 수행 하려면 메서드가 적절 한 속성 (예: System.object)에 액세스 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 및 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) .... n a m.</span><span class="sxs-lookup"><span data-stu-id="a7f48-143">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="a7f48-144">이 메서드의 구현에서는 항목이 사용자에 게 표시 될 수 있도록 하는 항목에 대 한 모든 형태의 액세스를 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-144">The implementation of this method should take into account any form of access to the item that might make the item visible to the user.</span></span> <span data-ttu-id="a7f48-145">예를 들어, 사용자가 파일 시스템 공급자 (Windows PowerShell에서 제공)를 통해 파일에 대 한 쓰기 권한을가지고 있지만 읽기 권한이 없는 경우 해당 파일은 여전히 존재 하 고 [system.object](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.ItemExists) 는 `true`을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-145">For example, if a user has write access to a file through the FileSystem provider (supplied by Windows PowerShell), but not read access, the file still exists and [System.Management.Automation.Provider.Itemcmdletprovider.Itemexists\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.ItemExists) returns `true`.</span></span> <span data-ttu-id="a7f48-146">구현에서 부모 항목을 확인 하 여 자식을 열거할 수 있는지 확인 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-146">Your implementation might require the checking of a parent item to see if the child can be enumerated.</span></span>

- <span data-ttu-id="a7f48-147">여러 항목을 작성할 때 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드는 약간의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-147">When writing multiple items, the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method can take some time.</span></span> <span data-ttu-id="a7f48-148">공급자를 디자인 하 여 한 번에 하나씩, [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.WriteItemObject) 를 사용 하 여 항목을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-148">You can design your provider to write the items using the [System.Management.Automation.Provider.Cmdletprovider.Writeitemobject\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.WriteItemObject) method one at a time.</span></span> <span data-ttu-id="a7f48-149">이 기술을 사용 하면 사용자에 게 스트림의 항목이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-149">Using this technique will present the items to the user in a stream.</span></span>

- <span data-ttu-id="a7f48-150">[Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 을 구현 하는 것은 순환 링크가 있는 경우 무한 재귀를 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-150">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="a7f48-151">이러한 조건을 반영 하려면 적절 한 종료 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-151">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

## <a name="attaching-dynamic-parameters-to-the-get-childitem-cmdlet"></a><span data-ttu-id="a7f48-152">Get ChildItem Cmdlet에 동적 매개 변수 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-152">Attaching Dynamic Parameters to the Get-ChildItem Cmdlet</span></span>

<span data-ttu-id="a7f48-153">경우에 따라 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 를 호출 하는 `Get-ChildItem` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-153">Sometimes the `Get-ChildItem` cmdlet that calls [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-154">이러한 동적 매개 변수를 제공 하려면 Windows PowerShell 컨테이너 공급자가 [Containercmdletprovider. Getchilditemsdynamicparameters \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItemsDynamicParameters) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-154">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditemsdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItemsDynamicParameters) method.</span></span> <span data-ttu-id="a7f48-155">이 메서드는 지정 된 경로에서 항목에 대 한 동적 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-155">This method retrieves dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-156">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `Get-ChildItem` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-156">The Windows PowerShell runtime uses the returned object to add the parameters to the `Get-ChildItem` cmdlet.</span></span>

<span data-ttu-id="a7f48-157">이 Windows PowerShell 컨테이너 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-157">This Windows PowerShell container provider does not implement this method.</span></span> <span data-ttu-id="a7f48-158">그러나 다음 코드는이 메서드의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-158">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidergetchilditemsdynamicparameters](Msh_samplestestcmdlets#testprovidergetchilditemsdynamicparameters)]  -->

## <a name="retrieving-child-item-names"></a><span data-ttu-id="a7f48-159">자식 항목 이름 검색</span><span class="sxs-lookup"><span data-stu-id="a7f48-159">Retrieving Child Item Names</span></span>

<span data-ttu-id="a7f48-160">자식 항목의 이름을 검색 하려면 Windows PowerShell 컨테이너 공급자는 `Name` 매개 변수를 지정할 때 `Get-ChildItem` cmdlet의 호출을 지원 하도록 [Containercmdletprovider. Getchildnames \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) 메서드를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-160">To retrieve the names of child items, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) method to support calls from the `Get-ChildItem` cmdlet when its `Name` parameter is specified.</span></span> <span data-ttu-id="a7f48-161">이 메서드는 cmdlet의 `returnAllContainers` 매개 변수가 지정 된 경우 모든 컨테이너에 대해 지정 된 경로 또는 자식 항목 이름에 대 한 자식 항목의 이름을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-161">This method retrieves the names of the child items for the specified path or child item names for all containers if the `returnAllContainers` parameter of the cmdlet is specified.</span></span> <span data-ttu-id="a7f48-162">자식 이름은 경로의 리프 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-162">A child name is the leaf portion of a path.</span></span> <span data-ttu-id="a7f48-163">예를 들어 c:\windows\system32\abc.dll 경로에 대 한 자식 이름은 "abc .dll"입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-163">For example, the child name for the path c:\windows\system32\abc.dll is "abc.dll".</span></span> <span data-ttu-id="a7f48-164">디렉터리 \ 디렉터리의 자식 이름이 "system32"입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-164">The child name for the directory c:\windows\system32 is "system32".</span></span>

<span data-ttu-id="a7f48-165">이 공급자에 대 한 [Containercmdletprovider. Getchildnames \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) 메서드의 구현은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-165">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) method for this provider.</span></span> <span data-ttu-id="a7f48-166">지정 된 경로가 테이블을 나타내는 경우에는 지정 된 경로가 Access 데이터베이스 (드라이브) 및 행 번호를 나타내는 경우이 메서드는 테이블 이름을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-166">Notice that the method retrieves table names if the specified path indicates the Access database (drive) and row numbers if the path indicates a table.</span></span>

```csharp
protected override void GetChildNames(string path,
                            ReturnContainers returnContainers)
{
    // If the path represented is a drive, then the child items are
    // tables. get the names of all the tables in the drive.
    if (PathIsDrive(path))
    {
        foreach (DatabaseTableInfo table in GetTables())
        {
            WriteItemObject(table.Name, path, true);
        } // foreach (DatabaseTableInfo...
    } // if (PathIsDrive...
    else
    {
        // Get type, table name and row number from path specified
        string tableName;
        int rowNumber;

        PathType type = GetNamesFromPath(path, out tableName, out rowNumber);

        if (type == PathType.Table)
        {
            // Get all the rows in the table and then write out the
            // row numbers.
            foreach (DatabaseRowInfo row in GetRows(tableName))
            {
                WriteItemObject(row.RowNumber, path, false);
            } // foreach (DatabaseRowInfo...
        }
        else if (type == PathType.Row)
        {
            // In this case the user has directly specified a row, hence
            // just give that particular row
            DatabaseRowInfo row = GetRow(tableName, rowNumber);

            WriteItemObject(row.RowNumber, path, false);
        }
        else
        {
            ThrowTerminatingInvalidPathException(path);
        }
    } // else
} // GetChildNames
```

:::code language="csharp" source="~/../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs" range="369-411":::

#### <a name="things-to-remember-about-implementing-getchildnames"></a><span data-ttu-id="a7f48-167">GetChildNames 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-167">Things to Remember About Implementing GetChildNames</span></span>

<span data-ttu-id="a7f48-168">다음 조건은 Containercmdletprovider의 구현에 적용 될 수 있습니다. [Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span><span class="sxs-lookup"><span data-stu-id="a7f48-168">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span></span>

- <span data-ttu-id="a7f48-169">공급자 클래스를 정의 하는 경우 Windows PowerShell 컨테이너 공급자가 ExpandWildcards, Filter, Include 또는 Exclude의 공급자 기능을 [system.object](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) 열거형에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-169">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="a7f48-170">이러한 경우 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 구현 하면 메서드에 전달 된 경로가 지정 된 기능의 요구 사항을 충족 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-170">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="a7f48-171">이 작업을 수행 하려면 메서드가 적절 한 속성 (예: System.object)에 액세스 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 및 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) .... n a m.</span><span class="sxs-lookup"><span data-stu-id="a7f48-171">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

  > [!NOTE]
  > <span data-ttu-id="a7f48-172">이 규칙의 예외는 cmdlet의 `returnAllContainers` 매개 변수가 지정 된 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-172">An exception to this rule occurs when the `returnAllContainers` parameter of the cmdlet is specified.</span></span> <span data-ttu-id="a7f48-173">이 경우 메서드는 컨테이너에 대 한 자식 이름을 검색 해야 합니다. 즉, 해당 이름이 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Filter)의 값과 일치 하지 않는 경우에도 [이를 검색](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include)해야 합니다 .이 경우에는 [이 속성의](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 값이 일치 하지 않는 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-173">In this case, the method should retrieve any child name for a container, even if it does not match the values of the [System.Management.Automation.Provider.Cmdletprovider.Filter\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Filter), [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include), or [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) properties.</span></span>

- <span data-ttu-id="a7f48-174">기본적으로이 메서드의 재정의는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 가 지정 되지 않은 경우 일반적으로 사용자에 게 숨겨지는 개체의 이름을 검색 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-174">By default, overrides of this method should not retrieve names of objects that are generally hidden from the user unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is specified.</span></span> <span data-ttu-id="a7f48-175">지정 된 경로가 컨테이너를 나타내는 경우에는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 지정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-175">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="a7f48-176">[Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) 을 구현 하는 것은 순환 링크가 있는 경우 무한 재귀를 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-176">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="a7f48-177">이러한 조건을 반영 하려면 적절 한 종료 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-177">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

## <a name="attaching-dynamic-parameters-to-the-get-childitem-cmdlet-name"></a><span data-ttu-id="a7f48-178">동적 매개 변수를 Get ChildItem Cmdlet (이름)에 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-178">Attaching Dynamic Parameters to the Get-ChildItem Cmdlet (Name)</span></span>

<span data-ttu-id="a7f48-179">경우에 따라 `Name` 매개 변수를 사용 하 여 `Get-ChildItem` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-179">Sometimes the `Get-ChildItem` cmdlet (with the `Name` parameter) requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-180">이러한 동적 매개 변수를 제공 하려면 Windows PowerShell 컨테이너 공급자가 [Containercmdletprovider. Getchildnamesdynamicparameters \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNamesDynamicParameters) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-180">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnamesdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNamesDynamicParameters) method.</span></span> <span data-ttu-id="a7f48-181">이 메서드는 지정 된 경로에서 항목에 대 한 동적 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-181">This method retrieves the dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-182">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `Get-ChildItem` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-182">The Windows PowerShell runtime uses the returned object to add the parameters to the `Get-ChildItem` cmdlet.</span></span>

<span data-ttu-id="a7f48-183">이 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-183">This provider does not implement this method.</span></span> <span data-ttu-id="a7f48-184">그러나 다음 코드는이 메서드의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-184">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidergetchildnamesdynamicparameters](Msh_samplestestcmdlets#testprovidergetchildnamesdynamicparameters)]  -->

## <a name="renaming-items"></a><span data-ttu-id="a7f48-185">항목 이름 바꾸기</span><span class="sxs-lookup"><span data-stu-id="a7f48-185">Renaming Items</span></span>

<span data-ttu-id="a7f48-186">항목의 이름을 바꾸려면 Windows PowerShell 컨테이너 공급자가 `Rename-Item` cmdlet의 호출을 지원 하도록 [Containercmdletprovider. Renameitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) 메서드를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-186">To rename an item, a Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method to support calls from the `Rename-Item` cmdlet.</span></span> <span data-ttu-id="a7f48-187">이 메서드는 지정 된 경로에 있는 항목의 이름을 제공 된 새 이름으로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-187">This method changes the name of the item at the specified path to the new name provided.</span></span> <span data-ttu-id="a7f48-188">새 이름은 항상 부모 항목 (컨테이너)에 상대적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-188">The new name must always be relative to the parent item (container).</span></span>

<span data-ttu-id="a7f48-189">이 공급자는 [Containercmdletprovider. Renameitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) 메서드를 재정의 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-189">This provider does not override the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method.</span></span> <span data-ttu-id="a7f48-190">그러나 다음은 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-190">However, the following is the default implementation.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderrenameitem](Msh_samplestestcmdlets#testproviderrenameitem)]  -->

#### <a name="things-to-remember-about-implementing-renameitem"></a><span data-ttu-id="a7f48-191">RenameItem 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-191">Things to Remember About Implementing RenameItem</span></span>

<span data-ttu-id="a7f48-192">다음 조건은 Containercmdletprovider의 구현에 적용 될 수 있습니다. [Renameitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem):</span><span class="sxs-lookup"><span data-stu-id="a7f48-192">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem):</span></span>

- <span data-ttu-id="a7f48-193">공급자 클래스를 정의 하는 경우 Windows PowerShell 컨테이너 공급자가 ExpandWildcards, Filter, Include 또는 Exclude의 공급자 기능을 [system.object](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) 열거형에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-193">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="a7f48-194">이러한 경우 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 구현 하면 메서드에 전달 된 경로가 지정 된 기능의 요구 사항을 충족 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-194">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="a7f48-195">이 작업을 수행 하려면 메서드가 적절 한 속성 (예: System.object)에 액세스 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 및 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) .... n a m.</span><span class="sxs-lookup"><span data-stu-id="a7f48-195">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="a7f48-196">[Containercmdletprovider. Renameitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) 메서드는 이동 작업에 대 한 것이 아니라 항목의 이름만 수정 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-196">The [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method is intended for the modification of the name of an item only, and not for move operations.</span></span>
  <span data-ttu-id="a7f48-197">`newName` 매개 변수에 경로 구분 기호가 포함 되어 있거나, 그렇지 않은 경우 항목의 부모 위치가 변경 될 수 있는 경우 메서드를 구현 하면 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-197">Your implementation of the method should write an error if the `newName` parameter contains path separators, or might otherwise cause the item to change its parent location.</span></span>

- <span data-ttu-id="a7f48-198">기본적으로이 메서드의 재정의는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 지정 하지 않는 한 개체의 이름을 바꾸지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-198">By default, overrides of this method should not rename objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is specified.</span></span> <span data-ttu-id="a7f48-199">지정 된 경로가 컨테이너를 나타내는 경우에는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 지정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-199">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="a7f48-200">[Containercmdletprovider. Renameitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) 메서드를 구현 하면 데이터 저장소를 변경 하기 전에를 호출 하 고 해당 반환 값을 확인 [해야 하는](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 경우를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-200">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="a7f48-201">이 메서드는 시스템 상태가 변경 될 때 (예: 파일 이름 바꾸기) 작업 실행을 확인 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-201">This method is used to confirm execution of an operation when a change is made to system state, for example, renaming files.</span></span>
  <span data-ttu-id="a7f48-202">Windows PowerShell 런타임이 사용자에 게 변경할 리소스의 [이름을 보내고,](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 표시 되는 항목을 결정 하는 데 사용 되는 모든 명령줄 설정이 나 기본 설정 변수를 고려 하 여 Windows PowerShell 런타임을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-202">[System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) sends the name of the resource to be changed to the user, with the Windows PowerShell runtime taking into account any command line settings or preference variables in determining what should be displayed.</span></span>

  <span data-ttu-id="a7f48-203">Containercmdletprovider를 호출한 후에는 [ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 가 `true`를 반환 합니다. Renameitem \* 메서드는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) 를 호출 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) 메서드를 호출 하는 경우에는 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-203">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns `true`, the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method.</span></span> <span data-ttu-id="a7f48-204">이 메서드는 사용자에 게 확인 메시지를 보내 작업을 계속 해야 하는 경우 추가 피드백을 허용 하도록 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-204">This method sends a message a confirmation message to the user to allow additional feedback to say if the operation should be continued.</span></span> <span data-ttu-id="a7f48-205">공급자는 잠재적으로 위험한 시스템 수정에 대 한 추가 검사로 [계속 합니다.](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue)</span><span class="sxs-lookup"><span data-stu-id="a7f48-205">A provider should call [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-rename-item-cmdlet"></a><span data-ttu-id="a7f48-206">항목 이름 바꾸기 Cmdlet에 동적 매개 변수 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-206">Attaching Dynamic Parameters to the Rename-Item Cmdlet</span></span>

<span data-ttu-id="a7f48-207">경우에 따라 `Rename-Item` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-207">Sometimes the `Rename-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-208">이러한 동적 매개 변수를 제공 하려면 Windows PowerShell 컨테이너 공급자가 [Containercmdletprovider. Renameitemdynamicparameters \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItemDynamicParameters) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-208">To provide these dynamic parameters, Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Renameitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItemDynamicParameters) method.</span></span> <span data-ttu-id="a7f48-209">이 메서드는 지정 된 경로에서 항목에 대 한 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-209">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-210">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `Rename-Item` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-210">The Windows PowerShell runtime uses the returned object to add the parameters to the `Rename-Item` cmdlet.</span></span>

<span data-ttu-id="a7f48-211">이 컨테이너 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-211">This container provider does not implement this method.</span></span> <span data-ttu-id="a7f48-212">그러나 다음 코드는이 메서드의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-212">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderrenameitemdynamicparameters](Msh_samplestestcmdlets#testproviderrenameitemdynamicparameters)]  -->

## <a name="creating-new-items"></a><span data-ttu-id="a7f48-213">새 항목 만들기</span><span class="sxs-lookup"><span data-stu-id="a7f48-213">Creating New Items</span></span>

<span data-ttu-id="a7f48-214">새 항목을 만들려면 컨테이너 공급자가 `New-Item` cmdlet의 호출을 지원 하기 위해 [Containercmdletprovider. Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-214">To create new items, a container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method to support calls from the `New-Item` cmdlet.</span></span> <span data-ttu-id="a7f48-215">이 메서드는 지정 된 경로에 있는 데이터 항목을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-215">This method creates a data item located at the specified path.</span></span> <span data-ttu-id="a7f48-216">Cmdlet의 `type` 매개 변수에는 새 항목에 대 한 공급자 정의 형식이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-216">The `type` parameter of the cmdlet contains the provider-defined type for the new item.</span></span> <span data-ttu-id="a7f48-217">예를 들어 FileSystem 공급자는 값이 "file" 또는 "directory" 인 `type` 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-217">For example, the FileSystem provider uses a `type` parameter with a value of "file" or "directory".</span></span> <span data-ttu-id="a7f48-218">Cmdlet의 `newItemValue` 매개 변수는 새 항목의 공급자별 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-218">The `newItemValue` parameter of the cmdlet specifies a provider-specific value for the new item.</span></span>

<span data-ttu-id="a7f48-219">이 공급자에 대 한 [Containercmdletprovider. Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드의 구현은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-219">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method for this provider.</span></span>

```csharp
protected override void NewItem( string path, string type, object newItemValue )
{
    // Create the new item here after
    // performing necessary validations
    //
    // WriteItemObject(newItemValue, path, false);

    // Example
    //
    // if (ShouldProcess(path, "new item"))
    // {
    //      // Create a new item and then call WriteObject
    //      WriteObject(newItemValue, path, false);
    // }

} // NewItem
```

:::code language="csharp" source="~/../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs" range="939-955":::

#### <a name="things-to-remember-about-implementing-newitem"></a><span data-ttu-id="a7f48-220">NewItem 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-220">Things to Remember About Implementing NewItem</span></span>

<span data-ttu-id="a7f48-221">다음 조건은 Containercmdletprovider의 구현에 적용 될 수 있습니다. [Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span><span class="sxs-lookup"><span data-stu-id="a7f48-221">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span></span>

- <span data-ttu-id="a7f48-222">[Containercmdletprovider Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드는 `type` 매개 변수에 전달 된 문자열의 대/소문자를 구분 하지 않는 비교를 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-222">The [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should perform a case-insensitive comparison of the string passed in the `type` parameter.</span></span>
  <span data-ttu-id="a7f48-223">또한 모호한 일치 항목을 최소한으로 허용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-223">It should also allow for least ambiguous matches.</span></span> <span data-ttu-id="a7f48-224">예를 들어 "file" 및 "directory" 유형의 경우 모호성을 위해 첫 문자만 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-224">For example, for the types "file" and "directory", only the first letter is required to disambiguate.</span></span> <span data-ttu-id="a7f48-225">`type` 매개 변수가 공급자가 만들 수 없는 형식을 나타내는 경우 [Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드는 공급자가 만들 수 있는 형식을 나타내는 메시지와 함께 ArgumentException을 써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-225">If the `type` parameter indicates a type your provider cannot create, the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should write an ArgumentException with a message indicating the types the provider can create.</span></span>

- <span data-ttu-id="a7f48-226">`newItemValue` 매개 변수의 경우 [Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드를 구현 하 여 최소한의 문자열을 허용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-226">For the `newItemValue` parameter, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method is recommended to accept strings at a minimum.</span></span> <span data-ttu-id="a7f48-227">동일한 경로에 대 한 [Getitem \*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.GetItem) 메서드에서 검색 된 개체의 형식에도 동의 해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="a7f48-227">It should also accept the type of object that is retrieved by the [System.Management.Automation.Provider.Itemcmdletprovider.Getitem\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.GetItem) method for the same path.</span></span> <span data-ttu-id="a7f48-228">[Containercmdletprovider. Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드는 [languageprimitives.physicalhash. convertto-html \*](/dotnet/api/System.Management.Automation.LanguagePrimitives.ConvertTo) 메서드를 사용 하 여 형식을 원하는 형식으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-228">The [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method can use the [System.Management.Automation.Languageprimitives.Convertto\*](/dotnet/api/System.Management.Automation.LanguagePrimitives.ConvertTo) method to convert types to the desired type.</span></span>

- <span data-ttu-id="a7f48-229">[Containercmdletprovider. Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) 메서드를 구현 하면 데이터 저장소를 변경 하기 전에를 호출 하 고 해당 반환 값을 확인 [해야 하는](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 경우를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-229">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="a7f48-230">Containercmdletprovider를 호출한 후에는 [ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 가 true를 반환 하 고, [Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) [메서드는 잠재적](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) 으로 위험한 시스템 수정에 대 한 추가 검사로 메서드를 호출 해야 하는 경우를 들 수 있습니다 (예를 들어).</span><span class="sxs-lookup"><span data-stu-id="a7f48-230">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns true, the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-new-item-cmdlet"></a><span data-ttu-id="a7f48-231">새 항목 Cmdlet에 동적 매개 변수 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-231">Attaching Dynamic Parameters to the New-Item Cmdlet</span></span>

<span data-ttu-id="a7f48-232">경우에 따라 `New-Item` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-232">Sometimes the `New-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-233">이러한 동적 매개 변수를 제공 하려면 컨테이너 공급자가 Containercmdletprovider. n e t [parameters \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItemDynamicParameters) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-233">To provide these dynamic parameters, the container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Newitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItemDynamicParameters) method.</span></span> <span data-ttu-id="a7f48-234">이 메서드는 지정 된 경로에서 항목에 대 한 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-234">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-235">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `New-Item` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-235">The Windows PowerShell runtime uses the returned object to add the parameters to the `New-Item` cmdlet.</span></span>

<span data-ttu-id="a7f48-236">이 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-236">This provider does not implement this method.</span></span> <span data-ttu-id="a7f48-237">그러나 다음 코드는이 메서드의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-237">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidernewitemdynamicparameters](Msh_samplestestcmdlets#testprovidernewitemdynamicparameters)]  -->

## <a name="removing-items"></a><span data-ttu-id="a7f48-238">항목 제거</span><span class="sxs-lookup"><span data-stu-id="a7f48-238">Removing Items</span></span>

<span data-ttu-id="a7f48-239">항목을 제거 하려면 Windows PowerShell 공급자가 `Remove-Item` cmdlet의 호출을 지원 하도록 [Containercmdletprovider. Removeitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) 메서드를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-239">To remove items, the Windows PowerShell provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method to support calls from the `Remove-Item` cmdlet.</span></span> <span data-ttu-id="a7f48-240">이 메서드는 지정 된 경로에서 데이터 저장소의 항목을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-240">This method deletes an item from the data store at the specified path.</span></span> <span data-ttu-id="a7f48-241">`Remove-Item` cmdlet의 `recurse` 매개 변수가 `true`으로 설정 된 경우 메서드는 해당 수준에 관계 없이 모든 자식 항목을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-241">If the `recurse` parameter of the `Remove-Item` cmdlet is set to `true`, the method removes all child items regardless of their level.</span></span> <span data-ttu-id="a7f48-242">매개 변수가 `false`로 설정 된 경우 메서드는 지정 된 경로에서 단일 항목만 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-242">If the parameter is set to `false`, the method removes only a single item at the specified path.</span></span>

<span data-ttu-id="a7f48-243">이 공급자는 항목 제거를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-243">This provider does not support item removal.</span></span> <span data-ttu-id="a7f48-244">그러나 다음 코드는 [Containercmdletprovider. Removeitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem)의 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-244">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderremoveitem](Msh_samplestestcmdlets#testproviderremoveitem)]  -->

#### <a name="things-to-remember-about-implementing-removeitem"></a><span data-ttu-id="a7f48-245">RemoveItem 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-245">Things to Remember About Implementing RemoveItem</span></span>

<span data-ttu-id="a7f48-246">다음 조건은 Containercmdletprovider의 구현에 적용 될 수 있습니다. [Newitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span><span class="sxs-lookup"><span data-stu-id="a7f48-246">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span></span>

- <span data-ttu-id="a7f48-247">공급자 클래스를 정의 하는 경우 Windows PowerShell 컨테이너 공급자가 ExpandWildcards, Filter, Include 또는 Exclude의 공급자 기능을 [system.object](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) 열거형에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-247">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="a7f48-248">이러한 경우 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 구현 하면 메서드에 전달 된 경로가 지정 된 기능의 요구 사항을 충족 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-248">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="a7f48-249">이 작업을 수행 하려면 메서드가 적절 한 속성 (예: System.object)에 액세스 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 및 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) .... n a m.</span><span class="sxs-lookup"><span data-stu-id="a7f48-249">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="a7f48-250">기본적으로이 메서드의 재정의는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 가 true로 설정 된 경우를 제외 하 고는 개체를 제거 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-250">By default, overrides of this method should not remove objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to true.</span></span> <span data-ttu-id="a7f48-251">지정 된 경로가 컨테이너를 나타내는 경우에는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 지정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-251">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="a7f48-252">[Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) 을 구현 하는 것은 순환 링크가 있는 경우 무한 재귀를 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-252">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="a7f48-253">이러한 조건을 반영 하려면 적절 한 종료 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-253">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

- <span data-ttu-id="a7f48-254">[Containercmdletprovider. Removeitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) 메서드를 구현 하면 데이터 저장소를 변경 하기 전에를 호출 하 고 해당 반환 값을 확인 [해야 하는](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 경우를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-254">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="a7f48-255">Containercmdletprovider를 호출한 후에는 [ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 가 `true`을 반환 하 고, [Removeitem \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) [메서드는 잠재적](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) 으로 위험한 시스템 수정에 대 한 추가 검사로 메서드를 호출 해야 하는 경우를 들 수 있습니다 (예를 들어</span><span class="sxs-lookup"><span data-stu-id="a7f48-255">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns `true`, the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-remove-item-cmdlet"></a><span data-ttu-id="a7f48-256">항목을 제거 하는 Cmdlet에 동적 매개 변수 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-256">Attaching Dynamic Parameters to the Remove-Item Cmdlet</span></span>

<span data-ttu-id="a7f48-257">경우에 따라 `Remove-Item` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-257">Sometimes the `Remove-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-258">이러한 동적 매개 변수를 제공 하려면 컨테이너 공급자가 이러한 매개 변수를 처리 하는 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters) 을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-258">To provide these dynamic parameters, the container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters) method to handle these parameters.</span></span> <span data-ttu-id="a7f48-259">이 메서드는 지정 된 경로에서 항목에 대 한 동적 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-259">This method retrieves the dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-260">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `Remove-Item` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-260">The Windows PowerShell runtime uses the returned object to add the parameters to the `Remove-Item` cmdlet.</span></span>

<span data-ttu-id="a7f48-261">이 컨테이너 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-261">This container provider does not implement this method.</span></span> <span data-ttu-id="a7f48-262">그러나 다음 코드는 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters)의 기본 구현으로,이는 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-262">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderremoveitemdynamicparameters](Msh_samplestestcmdlets#testproviderremoveitemdynamicparameters)]  -->

## <a name="querying-for-child-items"></a><span data-ttu-id="a7f48-263">자식 항목 쿼리</span><span class="sxs-lookup"><span data-stu-id="a7f48-263">Querying for Child Items</span></span>

<span data-ttu-id="a7f48-264">지정 된 경로에 자식 항목이 있는지 여부를 확인 하려면 Windows PowerShell 컨테이너 공급자가 [Containercmdletprovider \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) 메서드를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-264">To check to see if child items exist at the specified path, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method.</span></span> <span data-ttu-id="a7f48-265">이 메서드는 항목이 자식 항목을 포함 하는 경우 `true`을 반환 하 고, 그렇지 않으면 `false` 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-265">This method returns `true` if the item has children, and `false` otherwise.</span></span> <span data-ttu-id="a7f48-266">Null 또는 빈 경로의 경우 메서드는 데이터 저장소의 모든 항목을 자식으로 간주 하 고 `true`반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-266">For a null or empty path, the method considers any items in the data store to be children and returns `true`.</span></span>

<span data-ttu-id="a7f48-267">다음은 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) 에 대 한 재정의입니다 (예를 들어,</span><span class="sxs-lookup"><span data-stu-id="a7f48-267">Here is the override for the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method.</span></span> <span data-ttu-id="a7f48-268">청크 경로 도우미 메서드에 의해 생성 된 경로 파트가 세 개 이상일 경우에는 데이터베이스 컨테이너와 테이블 컨테이너만 정의 되어 있기 때문에 메서드는 `false`을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-268">If there are more than two path parts created by the ChunkPath helper method, the method returns `false`, since only a database container and a table container are defined.</span></span> <span data-ttu-id="a7f48-269">이 도우미 메서드에 대 한 자세한 내용은 [Windows PowerShell 항목 공급자 만들기](./creating-a-windows-powershell-item-provider.md)에서 chunkpath 메서드를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-269">For more information about this helper method, see the ChunkPath method is discussed in [Creating a Windows PowerShell Item Provider](./creating-a-windows-powershell-item-provider.md).</span></span>

```csharp
protected override bool HasChildItems( string path )
{
    return false;
} // HasChildItems
```

:::code language="csharp" source="~/../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs" range="1094-1097":::

#### <a name="things-to-remember-about-implementing-haschilditems"></a><span data-ttu-id="a7f48-270">HasChildItems 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-270">Things to Remember About Implementing HasChildItems</span></span>

<span data-ttu-id="a7f48-271">Containercmdletprovider의 구현에는 다음 조건이 적용 될 수 있습니다. [\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems):</span><span class="sxs-lookup"><span data-stu-id="a7f48-271">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems):</span></span>

- <span data-ttu-id="a7f48-272">컨테이너 공급자가 흥미로운 탑재 지점이 포함 된 루트를 노출 하는 경우, [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) 의 구현은 null 또는 빈 문자열이 경로에 전달 될 때 `true`을 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-272">If the container provider exposes a root that contains interesting mount points, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method should return `true` when a null or an empty string is passed in for the path.</span></span>

## <a name="copying-items"></a><span data-ttu-id="a7f48-273">항목 복사</span><span class="sxs-lookup"><span data-stu-id="a7f48-273">Copying Items</span></span>

<span data-ttu-id="a7f48-274">항목을 복사 하려면 컨테이너 공급자가 `Copy-Item` cmdlet의 호출을 지원 하기 위해 [ContainerCmdletProvider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-274">To copy items, the container provider must implement the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method to support calls from the `Copy-Item` cmdlet.</span></span> <span data-ttu-id="a7f48-275">이 메서드는 cmdlet의 `path` 매개 변수가 나타내는 위치에서 `copyPath` 매개 변수가 나타내는 위치로 데이터 항목을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-275">This method copies a data item from the location indicated by the `path` parameter of the cmdlet to the location indicated by the `copyPath` parameter.</span></span> <span data-ttu-id="a7f48-276">`recurse` 매개 변수가 지정 된 경우 메서드는 모든 하위 컨테이너를 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-276">If the `recurse` parameter is specified, the method copies all sub-containers.</span></span> <span data-ttu-id="a7f48-277">매개 변수를 지정 하지 않으면 메서드는 단일 수준의 항목만 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-277">If the parameter is not specified, the method copies only a single level of items.</span></span>

<span data-ttu-id="a7f48-278">이 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-278">This provider does not implement this method.</span></span> <span data-ttu-id="a7f48-279">그러나 다음 코드는 ContainerCmdletProvider의 기본 구현입니다 .이 [항목](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem)은</span><span class="sxs-lookup"><span data-stu-id="a7f48-279">However, the following code is the default implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidercopyitem](Msh_samplestestcmdlets#testprovidercopyitem)]  -->

#### <a name="things-to-remember-about-implementing-copyitem"></a><span data-ttu-id="a7f48-280">CopyItem 구현에 대해 기억할 사항</span><span class="sxs-lookup"><span data-stu-id="a7f48-280">Things to Remember About Implementing CopyItem</span></span>

<span data-ttu-id="a7f48-281">[ContainerCmdletProvider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem)을 구현 하는 데 다음 조건이 적용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-281">The following conditions may apply to your implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem):</span></span>

- <span data-ttu-id="a7f48-282">공급자 클래스를 정의 하는 경우 Windows PowerShell 컨테이너 공급자가 ExpandWildcards, Filter, Include 또는 Exclude의 공급자 기능을 [system.object](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) 열거형에서 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-282">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="a7f48-283">이러한 경우 [Containercmdletprovider. Getchilditems \*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) 메서드를 구현 하면 메서드에 전달 된 경로가 지정 된 기능의 요구 사항을 충족 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-283">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="a7f48-284">이 작업을 수행 하려면 메서드가 적절 한 속성 (예: System.object)에 액세스 해야 합니다. [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) 및 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) .... n a m.</span><span class="sxs-lookup"><span data-stu-id="a7f48-284">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="a7f48-285">기본적으로이 메서드의 재정의는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 `true`로 설정 하지 않으면 기존 개체를 통해 개체를 복사 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-285">By default, overrides of this method should not copy objects over existing objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to `true`.</span></span> <span data-ttu-id="a7f48-286">예를 들어 c:\temp\abc.txt [\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 속성이 `true`로 설정 되어 있지 않으면 파일 시스템 공급자는 기존 c:\abc.txt 파일을 통해를 복사 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-286">For example, the FileSystem provider will not copy c:\temp\abc.txt over an existing c:\abc.txt file unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to `true`.</span></span> <span data-ttu-id="a7f48-287">`copyPath` 매개 변수에 지정 된 경로가 존재 하 고 컨테이너를 나타내는 경우에는 [system.object](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) 를 지정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-287">If the path specified in the `copyPath` parameter exists and indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span> <span data-ttu-id="a7f48-288">이 경우 [ContainerCmdletProvider 항목](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) 은 `path` 매개 변수에 표시 된 항목을 `copyPath` 매개 변수로 표시 되는 컨테이너에 복사 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-288">In this case, [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) should copy the item indicated by the `path` parameter to the container indicated by the `copyPath` parameter as a child.</span></span>

- <span data-ttu-id="a7f48-289">[ContainerCmdletProvider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) 를 구현 하는 것은 순환 링크가 있는 경우 무한 재귀를 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-289">Your implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="a7f48-290">이러한 조건을 반영 하려면 적절 한 종료 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-290">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

- <span data-ttu-id="a7f48-291">[ContainerCmdletProvider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) 메서드를 구현 하면 데이터 저장소를 변경 하기 전에 해당 반환 값을 확인 [하 고 해당 반환 값을 확인](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 하는 것도 가능 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-291">Your implementation of the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="a7f48-292">ContainerCmdletProvider를 호출한 후에는 [ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) 가 true를 반환 하 고, 잠재적으로 위험한 시스템 수정에 대 한 추가 확인으로 [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) [메서드를](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) 호출 해야 하는 경우를 들 수 있습니다 (예를 들어) 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-292">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns true, the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span> <span data-ttu-id="a7f48-293">이러한 메서드를 호출 하는 방법에 대 한 자세한 내용은 [항목 이름 바꾸기](#renaming-items)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-293">For more information about calling these methods, see [Rename Items](#renaming-items).</span></span>

## <a name="attaching-dynamic-parameters-to-the-copy-item-cmdlet"></a><span data-ttu-id="a7f48-294">복사 항목 Cmdlet에 동적 매개 변수 연결</span><span class="sxs-lookup"><span data-stu-id="a7f48-294">Attaching Dynamic Parameters to the Copy-Item Cmdlet</span></span>

<span data-ttu-id="a7f48-295">경우에 따라 `Copy-Item` cmdlet에는 런타임에 동적으로 지정 되는 추가 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-295">Sometimes the `Copy-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="a7f48-296">이러한 동적 매개 변수를 제공 하려면 Windows PowerShell 컨테이너 공급자가 이러한 매개 변수를 처리 하는 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters) 을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-296">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters) method to handle these parameters.</span></span> <span data-ttu-id="a7f48-297">이 메서드는 지정 된 경로에서 항목에 대 한 매개 변수를 검색 하 고 cmdlet 클래스 또는 [Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) 개체와 유사한 구문 분석 특성이 있는 속성 및 필드가 있는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-297">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="a7f48-298">Windows PowerShell 런타임은 반환 된 개체를 사용 하 여 `Copy-Item` cmdlet에 매개 변수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-298">The Windows PowerShell runtime uses the returned object to add the parameters to the `Copy-Item` cmdlet.</span></span>

<span data-ttu-id="a7f48-299">이 공급자는이 메서드를 구현 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-299">This provider does not implement this method.</span></span> <span data-ttu-id="a7f48-300">그러나 다음 코드는 [Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters)의 기본 구현으로,이는 기본 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-300">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidercopyitemdynamicparameters](Msh_samplestestcmdlets#testprovidercopyitemdynamicparameters)]  -->

## <a name="code-sample"></a><span data-ttu-id="a7f48-301">코드 예제</span><span class="sxs-lookup"><span data-stu-id="a7f48-301">Code Sample</span></span>

<span data-ttu-id="a7f48-302">전체 샘플 코드는 [AccessDbProviderSample04 코드 샘플](./accessdbprovidersample04-code-sample.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-302">For complete sample code, see [AccessDbProviderSample04 Code Sample](./accessdbprovidersample04-code-sample.md).</span></span>

## <a name="building-the-windows-powershell-provider"></a><span data-ttu-id="a7f48-303">Windows PowerShell 공급자 빌드</span><span class="sxs-lookup"><span data-stu-id="a7f48-303">Building the Windows PowerShell Provider</span></span>

<span data-ttu-id="a7f48-304">[Cmdlet, 공급자 및 호스트 응용 프로그램을 등록 하는 방법을](/previous-versions/ms714644(v=vs.85))참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a7f48-304">See [How to Register Cmdlets, Providers, and Host Applications](/previous-versions/ms714644(v=vs.85)).</span></span>

## <a name="testing-the-windows-powershell-provider"></a><span data-ttu-id="a7f48-305">Windows PowerShell 공급자 테스트</span><span class="sxs-lookup"><span data-stu-id="a7f48-305">Testing the Windows PowerShell Provider</span></span>

<span data-ttu-id="a7f48-306">Windows powershell 공급자를 Windows PowerShell에 등록 한 경우 명령줄에서 지원 되는 cmdlet을 실행 하 여 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-306">When your Windows PowerShell provider has been registered with Windows PowerShell, you can test it by running the supported cmdlets on the command line.</span></span> <span data-ttu-id="a7f48-307">다음 예제 출력에서는 가상의 Access 데이터베이스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-307">Be aware that the following example output uses a fictitious Access database.</span></span>

1. <span data-ttu-id="a7f48-308">`Get-ChildItem` cmdlet을 실행 하 여 Access 데이터베이스의 Customers 테이블에서 자식 항목 목록을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-308">Run the `Get-ChildItem` cmdlet to retrieve the list of child items from a Customers table in the Access database.</span></span>

   ```powershell
   Get-ChildItem mydb:customers
   ```

   <span data-ttu-id="a7f48-309">다음 출력이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-309">The following output appears.</span></span>

   ```output
   PSPath        : AccessDB::customers
   PSDrive       : mydb
   PSProvider    : System.Management.Automation.ProviderInfo
   PSIsContainer : True
   Data          : System.Data.DataRow
   Name          : Customers
   RowCount      : 91
   Columns       :
   ```

2. <span data-ttu-id="a7f48-310">`Get-ChildItem` cmdlet을 다시 실행 하 여 테이블의 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-310">Run the `Get-ChildItem` cmdlet again to retrieve the data of a table.</span></span>

   ```powershell
   (Get-ChildItem mydb:customers).data
   ```

   <span data-ttu-id="a7f48-311">다음 출력이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-311">The following output appears.</span></span>

   ```output
   TABLE_CAT   : c:\PS\northwind
   TABLE_SCHEM :
   TABLE_NAME  : Customers
   TABLE_TYPE  : TABLE
   REMARKS     :
   ```

3. <span data-ttu-id="a7f48-312">이제 `Get-Item` cmdlet을 사용 하 여 데이터 테이블의 0 행에 있는 항목을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-312">Now use the `Get-Item` cmdlet to retrieve the items at row 0 in the data table.</span></span>

   ```powershell
   Get-Item mydb:\customers\0
   ```

   <span data-ttu-id="a7f48-313">다음 출력이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-313">The following output appears.</span></span>

   ```output
   PSPath        : AccessDB::customers\0
   PSDrive       : mydb
   PSProvider    : System.Management.Automation.ProviderInfo
   PSIsContainer : False
   Data          : System.Data.DataRow
   RowNumber     : 0
   ```

4. <span data-ttu-id="a7f48-314">`Get-Item`를 다시 사용 하 여 0 행의 항목에 대 한 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-314">Reuse `Get-Item` to retrieve the data for the items in row 0.</span></span>

   ```powershell
   (Get-Item mydb:\customers\0).data
   ```

   <span data-ttu-id="a7f48-315">다음 출력이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-315">The following output appears.</span></span>

   ```output
   CustomerID   : 1234
   CompanyName  : Fabrikam
   ContactName  : Eric Gruber
   ContactTitle : President
   Address      : 4567 Main Street
   City         : Buffalo
   Region       : NY
   PostalCode   : 98052
   Country      : USA
   Phone        : (425) 555-0100
   Fax          : (425) 555-0101
   ```

5. <span data-ttu-id="a7f48-316">이제 `New-Item` cmdlet을 사용 하 여 기존 테이블에 행을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-316">Now use the `New-Item` cmdlet to add a row to an existing table.</span></span> <span data-ttu-id="a7f48-317">`Path` 매개 변수는 행의 전체 경로를 지정 하 고 테이블의 기존 행 수보다 큰 행 번호를 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-317">The `Path` parameter specifies the full path to the row, and must indicate a row number that is greater than the existing number of rows in the table.</span></span> <span data-ttu-id="a7f48-318">`Type` 매개 변수는 추가할 항목의 형식을 지정 하는 "row"를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-318">The `Type` parameter indicates "row" to specify that type of item to add.</span></span>
   <span data-ttu-id="a7f48-319">마지막으로 `Value` 매개 변수는 행의 열 값에 대 한 쉼표로 구분 된 목록을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-319">Finally, the `Value` parameter specifies a comma-delimited list of column values for the row.</span></span>

   ```powershell
   New-Item -Path mydb:\Customers\3 -ItemType "row" -Value "3,CustomerFirstName,CustomerLastName,CustomerEmailAddress,CustomerTitle,CustomerCompany,CustomerPhone, CustomerAddress,CustomerCity,CustomerState,CustomerZip,CustomerCountry"
   ```

6. <span data-ttu-id="a7f48-320">다음과 같이 새 항목 작업이 올바른지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-320">Verify the correctness of the new item operation as follows.</span></span>

   ```none
   PS mydb:\> cd Customers
   PS mydb:\Customers> (Get-Item 3).data
   ```

   <span data-ttu-id="a7f48-321">다음 출력이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7f48-321">The following output appears.</span></span>

   ```output
   ID        : 3
   FirstName : Eric
   LastName  : Gruber
   Email     : ericgruber@fabrikam.com
   Title     : President
   Company   : Fabrikam
   WorkPhone : (425) 555-0100
   Address   : 4567 Main Street
   City      : Buffalo
   State     : NY
   Zip       : 98052
   Country   : USA
   ```

## <a name="see-also"></a><span data-ttu-id="a7f48-322">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a7f48-322">See Also</span></span>

[<span data-ttu-id="a7f48-323">Windows PowerShell 공급자 만들기</span><span class="sxs-lookup"><span data-stu-id="a7f48-323">Creating Windows PowerShell Providers</span></span>](./how-to-create-a-windows-powershell-provider.md)

[<span data-ttu-id="a7f48-324">Windows PowerShell 공급자 디자인</span><span class="sxs-lookup"><span data-stu-id="a7f48-324">Designing Your Windows PowerShell Provider</span></span>](./designing-your-windows-powershell-provider.md)

[<span data-ttu-id="a7f48-325">항목 Windows PowerShell 공급자 구현</span><span class="sxs-lookup"><span data-stu-id="a7f48-325">Implementing an Item Windows PowerShell Provider</span></span>](./creating-a-windows-powershell-item-provider.md)

[<span data-ttu-id="a7f48-326">탐색 Windows PowerShell 공급자 구현</span><span class="sxs-lookup"><span data-stu-id="a7f48-326">Implementing a Navigation Windows PowerShell Provider</span></span>](./creating-a-windows-powershell-navigation-provider.md)

<span data-ttu-id="a7f48-327">[Cmdlet, 공급자 및 호스트 응용 프로그램을 등록 하는 방법](/previous-versions/ms714644(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="a7f48-327">[How to Register Cmdlets, Providers, and Host Applications](/previous-versions/ms714644(v=vs.85))</span></span>

[<span data-ttu-id="a7f48-328">Windows PowerShell SDK</span><span class="sxs-lookup"><span data-stu-id="a7f48-328">Windows PowerShell SDK</span></span>](../windows-powershell-reference.md)

[<span data-ttu-id="a7f48-329">Windows PowerShell 프로그래머 가이드</span><span class="sxs-lookup"><span data-stu-id="a7f48-329">Windows PowerShell Programmer's Guide</span></span>](./windows-powershell-programmer-s-guide.md)
