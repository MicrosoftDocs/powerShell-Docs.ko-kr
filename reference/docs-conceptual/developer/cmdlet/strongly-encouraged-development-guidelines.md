---
title: 권장 되는 개발 지침 | Microsoft Docs
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: 0906d0d37c66b8c1538a0b2e9e0f1ff2fba12ac0
ms.sourcegitcommit: 52a67bcd9d7bf3e8600ea4302d1fa8970ff9c998
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/15/2019
ms.locfileid: "72369342"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="df7dd-102">적극 권장되는 개발 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-102">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="df7dd-103">이 섹션에서는 cmdlet을 작성할 때 따라야 하는 지침을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-103">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="df7dd-104">Cmdlet을 디자인 하기 위한 지침과 cmdlet 코드를 작성 하기 위한 지침으로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-104">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="df7dd-105">이러한 지침은 모든 시나리오에 적용 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-105">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="df7dd-106">그러나 이러한 지침이 적용 되는 경우 이러한 지침을 따르지 않으면 사용자가 cmdlet을 사용 하는 경우 사용자에 게 좋지 않은 경험이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-106">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="df7dd-107">디자인 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-107">Design Guidelines</span></span>

- [<span data-ttu-id="df7dd-108">Cmdlet 이름에 특정 명사 사용 (SD01)</span><span class="sxs-lookup"><span data-stu-id="df7dd-108">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [<span data-ttu-id="df7dd-109">Cmdlet 이름으로 파스칼식 대/소문자 사용 (SD02)</span><span class="sxs-lookup"><span data-stu-id="df7dd-109">Use Pascal Case for Cmdlet Names (SD02)</span></span>](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [<span data-ttu-id="df7dd-110">매개 변수 디자인 지침 (SD03)</span><span class="sxs-lookup"><span data-stu-id="df7dd-110">Parameter Design Guidelines (SD03)</span></span>](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [<span data-ttu-id="df7dd-111">사용자에 게 피드백 제공 (SD04)</span><span class="sxs-lookup"><span data-stu-id="df7dd-111">Provide Feedback to the User (SD04)</span></span>](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [<span data-ttu-id="df7dd-112">Cmdlet 도움말 파일 만들기 (SD05)</span><span class="sxs-lookup"><span data-stu-id="df7dd-112">Create a Cmdlet Help File (SD05)</span></span>](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a><span data-ttu-id="df7dd-113">코드 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-113">Code Guidelines</span></span>

- [<span data-ttu-id="df7dd-114">매개 변수 코딩 (SC01)</span><span class="sxs-lookup"><span data-stu-id="df7dd-114">Coding Parameters (SC01)</span></span>](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [<span data-ttu-id="df7dd-115">잘 정의 된 파이프라인 입력 지원 (SC02)</span><span class="sxs-lookup"><span data-stu-id="df7dd-115">Support Well Defined Pipeline Input (SC02)</span></span>](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [<span data-ttu-id="df7dd-116">파이프라인에 단일 레코드 쓰기 (SC03)</span><span class="sxs-lookup"><span data-stu-id="df7dd-116">Write Single Records to the Pipeline (SC03)</span></span>](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [<span data-ttu-id="df7dd-117">Cmdlet에서 대/소문자를 구분 하지 않고 대/소문자를 유지 합니다 (SC04).</span><span class="sxs-lookup"><span data-stu-id="df7dd-117">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a><span data-ttu-id="df7dd-118">디자인 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-118">Design Guidelines</span></span>

<span data-ttu-id="df7dd-119">Cmdlet을 사용 하 여 cmdlet 및 기타 cmdlet을 사용 하는 것과 일관 된 사용자 환경을 보장 하기 위해 cmdlet을 디자인할 때는 다음 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-119">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="df7dd-120">상황에 적용 되는 디자인 지침을 찾았으면 유사한 지침에 대 한 코드 지침을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-120">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="df7dd-121">Cmdlet 이름에 특정 명사 사용 (SD01)</span><span class="sxs-lookup"><span data-stu-id="df7dd-121">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="df7dd-122">Cmdlet 이름에 사용 되는 명사는 사용자가 cmdlet을 검색할 수 있도록 매우 구체적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-122">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span> <span data-ttu-id="df7dd-123">"Server"와 같은 일반적인 명사를 제품 이름의 축약 된 버전으로 접두사로 붙입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-123">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="df7dd-124">예를 들어 명사가 Microsoft SQL Server의 인스턴스를 실행 하는 서버를 참조 하는 경우 "SQLServer"와 같은 명사를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-124">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="df7dd-125">사용자는 특정 명사와 승인 된 동사의 짧은 목록을 조합 하 여 cmdlet 이름 간의 중복을 방지 하면서 기능을 신속 하 게 검색 하 고 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-125">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="df7dd-126">사용자 환경을 개선 하기 위해 cmdlet 이름에 대해 선택 하는 명사는 단 수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-126">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="df7dd-127">예를 들어, **Get**process 대신 이름 `Get-Process`을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-127">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="df7dd-128">Cmdlet이 둘 이상의 항목에 대해 작동할 가능성이 있는 경우에도 모든 cmdlet 이름에 대해이 규칙을 따르는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-128">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="df7dd-129">Cmdlet 이름으로 파스칼식 대/소문자 사용 (SD02)</span><span class="sxs-lookup"><span data-stu-id="df7dd-129">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="df7dd-130">매개 변수 이름으로 파스칼식 대/소문자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-130">Use Pascal case for parameter names.</span></span> <span data-ttu-id="df7dd-131">즉, 동사에서 첫 글자를 대문자로 사용 하 고 모든 용어를 명사에 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-131">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="df7dd-132">예를 들어 "`Clear-ItemProperty`"입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-132">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="df7dd-133">매개 변수 디자인 지침 (SD03)</span><span class="sxs-lookup"><span data-stu-id="df7dd-133">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="df7dd-134">Cmdlet에는 작동 해야 하는 데이터를 수신 하는 매개 변수와 작업의 특징을 결정 하는 데 사용 되는 정보를 나타내는 매개 변수가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-134">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="df7dd-135">예를 들어 cmdlet은 파이프라인에서 데이터를 수신 하는 `Name` 매개 변수를 가질 수 있으며 cmdlet은이 cmdlet을 통해 작업을 강제로 수행할 수 있음을 나타내는 `Force` 매개 변수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-135">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="df7dd-136">Cmdlet에서 정의할 수 있는 매개 변수의 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-136">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="df7dd-137">표준 매개 변수 이름 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-137">Use Standard Parameter Names</span></span>

<span data-ttu-id="df7dd-138">사용자가 특정 매개 변수의 의미를 빠르게 확인할 수 있도록 cmdlet은 표준 매개 변수 이름을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-138">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="df7dd-139">보다 구체적인 이름이 필요한 경우 표준 매개 변수 이름을 사용 하 고 별칭으로 더 구체적인 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-139">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="df7dd-140">예를 들어 `Get-Service` cmdlet에는 제네릭 이름 (`Name`)과 보다 구체적인 별칭 (`ServiceName`)이 있는 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-140">For example, the `Get-Service` cmdlet has a  parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="df7dd-141">두 용어는 모두 매개 변수를 지정 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-141">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="df7dd-142">매개 변수 이름 및 해당 데이터 형식에 대 한 자세한 내용은 [Cmdlet 매개 변수 이름 및 기능 지침](./standard-cmdlet-parameter-names-and-types.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-142">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="df7dd-143">단일 매개 변수 이름 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-143">Use Singular Parameter Names</span></span>

<span data-ttu-id="df7dd-144">값이 단일 요소인 매개 변수에는 복수 이름을 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="df7dd-144">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="df7dd-145">여기에는 사용자가 요소를 하나만 포함 하는 배열 또는 목록을 제공할 수 있으므로 배열이 나 목록을 사용 하는 매개 변수가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-145">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="df7dd-146">복수형 매개 변수 이름은 매개 변수의 값이 항상 다중 요소 값인 경우에만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-146">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="df7dd-147">이러한 경우, cmdlet은 여러 요소가 제공 되었는지 확인 하 고, 여러 요소를 제공 하지 않으면 cmdlet이 사용자에 게 경고를 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-147">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="df7dd-148">매개 변수 이름으로 파스칼식 대/소문자 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-148">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="df7dd-149">매개 변수 이름으로 파스칼식 대/소문자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-149">Use Pascal case for parameter names.</span></span> <span data-ttu-id="df7dd-150">즉, 매개 변수 이름에서 각 단어의 첫 글자를 대문자로 바꿉니다 (이름의 첫 문자 포함).</span><span class="sxs-lookup"><span data-stu-id="df7dd-150">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="df7dd-151">예를 들어 매개 변수 이름 `ErrorAction`은 올바른 대문자 표시를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-151">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="df7dd-152">다음 매개 변수 이름에는 잘못 된 대/소문자가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-152">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="df7dd-153">옵션 목록을 사용 하는 매개 변수</span><span class="sxs-lookup"><span data-stu-id="df7dd-153">Parameters That Take a List of Options</span></span>

<span data-ttu-id="df7dd-154">옵션 집합에서 값을 선택할 수 있는 매개 변수를 만드는 방법에는 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-154">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="df7dd-155">유효한 값을 지정 하는 열거형 형식 (또는 기존 열거형 형식 사용)을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-155">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span> <span data-ttu-id="df7dd-156">그런 다음 열거형 형식을 사용 하 여 해당 형식의 매개 변수를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-156">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="df7dd-157">**ValidateSet** 특성을 매개 변수 선언에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-157">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="df7dd-158">이 특성에 대 한 자세한 내용은 [ValidateSet Attribute 선언](./validateset-attribute-declaration.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-158">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="df7dd-159">매개 변수에 표준 형식 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-159">Use Standard Types for Parameters</span></span>

<span data-ttu-id="df7dd-160">다른 cmdlet과의 일관성을 보장 하려면 가능한 경우 매개 변수에 표준 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-160">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="df7dd-161">다른 매개 변수에 사용 해야 하는 형식에 대 한 자세한 내용은 [표준 Cmdlet 매개 변수 이름 및 형식](./standard-cmdlet-parameter-names-and-types.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-161">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="df7dd-162">이 항목에서는 "활동 매개 변수"와 같은 표준 매개 변수 그룹의 이름 및 .NET Framework 유형을 설명 하는 여러 항목에 대 한 링크를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-162">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="df7dd-163">강력한 형식의 .NET Framework 형식 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-163">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="df7dd-164">매개 변수를 .NET Framework 형식으로 정의 하 여 더 나은 매개 변수 유효성 검사를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-164">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="df7dd-165">예를 들어 값 집합에서 하나의 값으로 제한 되는 매개 변수는 열거형 형식으로 정의 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-165">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="df7dd-166">URI (Uniform Resource Identifier) 값을 지원 하려면 매개 변수를 [system.uri](/dotnet/api/System.Uri) 형식으로 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-166">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="df7dd-167">자유 형식 텍스트 속성에 대 한 기본 문자열 매개 변수를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-167">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="df7dd-168">일관 된 매개 변수 형식 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-168">Use Consistent Parameter Types</span></span>

<span data-ttu-id="df7dd-169">동일한 매개 변수를 여러 cmdlet에서 사용 하는 경우 항상 동일한 매개 변수 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-169">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span>  <span data-ttu-id="df7dd-170">예를 들어 `Process` 매개 변수가 하나의 cmdlet에 대 한 [system.string 형식이 면](/dotnet/api/System.Int16) 다른 cmdlet에 대 한 `Process` 매개 변수를 [system.object](/dotnet/api/System.UInt16) 형식으로 만들지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="df7dd-170">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="df7dd-171">True 및 False를 사용 하는 매개 변수</span><span class="sxs-lookup"><span data-stu-id="df7dd-171">Parameters That Take True and False</span></span>

<span data-ttu-id="df7dd-172">매개 변수가 `true` 및 `false`만 사용 하는 경우 매개 변수를 [system.object](/dotnet/api/System.Management.Automation.SwitchParameter)형식으로 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-172">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span> <span data-ttu-id="df7dd-173">스위치 매개 변수는 명령에 지정 될 때 `true`으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-173">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="df7dd-174">매개 변수가 명령에 포함 되지 않은 경우 Windows PowerShell은 매개 변수 값을 0 @no__t로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-174">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="df7dd-175">부울 매개 변수를 정의 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="df7dd-175">Do not define Boolean parameters.</span></span>

<span data-ttu-id="df7dd-176">매개 변수가 3 개의 값을 구분 해야 하는 경우 $true, $false 및 "지정 되지 않음"으로 Nullable @ no__t-0bool > 형식의 매개 변수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-176">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span>  <span data-ttu-id="df7dd-177">세 번째 "지정 되지 않음" 값은 일반적으로 cmdlet이 개체의 부울 속성을 수정할 수 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-177">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="df7dd-178">이 경우 "지정 하지 않음"은 속성의 현재 값을 변경 하지 않음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-178">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="df7dd-179">매개 변수에 대 한 지원 배열</span><span class="sxs-lookup"><span data-stu-id="df7dd-179">Support Arrays for Parameters</span></span>

<span data-ttu-id="df7dd-180">사용자는 여러 인수에 대해 동일한 작업을 수행 해야 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-180">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="df7dd-181">이러한 사용자의 경우 cmdlet은 사용자가 인수를 매개 변수에 Windows PowerShell 변수로 전달할 수 있도록 배열을 매개 변수 입력으로 허용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-181">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="df7dd-182">예를 들어, [Get Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet은 검색할 프로세스의 이름을 식별 하는 문자열에 대해 배열을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-182">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="df7dd-183">PassThru 매개 변수 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-183">Support the PassThru Parameter</span></span>

<span data-ttu-id="df7dd-184">기본적으로 [Stop Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet과 같이 시스템을 수정 하는 많은 cmdlet은 개체의 "싱크" 역할을 하며 결과를 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-184">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="df7dd-185">이러한 cmdlet은 `PassThru` 매개 변수를 구현 하 여 cmdlet이 강제로 개체를 반환 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-185">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="df7dd-186">@No__t-0 매개 변수가 지정 된 경우 cmdlet은 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 메서드를 호출 하 여 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-186">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="df7dd-187">예를 들어 다음 명령은 Calc 프로세스를 중지 하 고 결과 프로세스를 파이프라인으로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-187">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="df7dd-188">대부분의 경우 Add, Set 및 New cmdlet은 `PassThru` 매개 변수를 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-188">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="df7dd-189">매개 변수 집합 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-189">Support Parameter Sets</span></span>

<span data-ttu-id="df7dd-190">Cmdlet은 단일 용도를 달성 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-190">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="df7dd-191">그러나 작업 또는 작업 대상을 설명 하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-191">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="df7dd-192">예를 들어 프로세스는 이름, 식별자 또는 프로세스 개체로 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-192">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="df7dd-193">Cmdlet은 해당 대상의 모든 적절 한 표현을 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-193">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="df7dd-194">일반적으로 cmdlet은 함께 작동 하는 매개 변수 집합 (매개 변수 집합 이라고 함)을 지정 하 여이 요구 사항을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-194">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="df7dd-195">단일 매개 변수는 원하는 수의 매개 변수 집합에 속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-195">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="df7dd-196">매개 변수 집합에 대 한 자세한 내용은 [Cmdlet 매개 변수 집합](./cmdlet-parameter-sets.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-196">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="df7dd-197">매개 변수 집합을 지정 하는 경우 집합의 매개 변수를 ValueFromPipeline로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-197">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="df7dd-198">**매개 변수** 특성을 선언 하는 방법에 대 한 자세한 내용은 [parameterattribute 선언](./parameter-attribute-declaration.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-198">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="df7dd-199">매개 변수 집합을 사용 하는 경우 기본 매개 변수 집합은 **Cmdlet** 특성에 의해 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-199">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="df7dd-200">기본 매개 변수 집합은 대화형 Windows PowerShell 세션에서 사용 될 가능성이 가장 높은 매개 변수를 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-200">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="df7dd-201">**Cmdlet** 특성을 선언 하는 방법에 대 한 자세한 내용은 [cmdletattribute 선언](./cmdlet-attribute-declaration.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-201">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="df7dd-202">사용자에 게 피드백 제공 (SD04)</span><span class="sxs-lookup"><span data-stu-id="df7dd-202">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="df7dd-203">이 섹션의 지침을 사용 하 여 사용자에 게 피드백을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-203">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="df7dd-204">이 피드백을 통해 사용자는 시스템에서 발생 하는 상황을 인식 하 고 관리 관련 결정을 더 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-204">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="df7dd-205">사용자는 Windows PowerShell 런타임을 통해 기본 설정 변수를 설정 하 여 `Write` 메서드에 대 한 각 호출의 출력을 처리 하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-205">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="df7dd-206">사용자는 시스템에서 정보를 표시 해야 하는지 여부를 결정 하는 변수와, 추가 작업을 수행 하기 전에 시스템에서 사용자를 쿼리해야 하는지 여부를 결정 하는 변수를 포함 하 여 몇 가지 기본 설정 변수를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-206">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="df7dd-207">WriteWarning, Writewarning 및 Writewarning 메서드를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-207">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="df7dd-208">Cmdlet에서 의도 하지 않은 결과가 발생할 수 있는 작업을 수행 하려고 할 때에는 cmdlet이 [system.object](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) 를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-208">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="df7dd-209">예를 들어 cmdlet이 읽기 전용 파일을 덮어쓰려고 하는 경우이 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-209">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="df7dd-210">Cmdlet은 사용자가 cmdlet이 수행 하는 작업에 대 한 세부 정보가 필요한 경우에는 [system.object](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) 를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-210">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="df7dd-211">예를 들어 cmdlet이 cmdlet이 수행 하는 작업에 대 한 추가 정보가 필요할 수 있는 시나리오가 있는 경우 cmdlet은이 정보를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-211">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="df7dd-212">개발자 또는 기술 지원 엔지니어가 cmdlet 작업의 손상 원인을 이해 해야 하는 경우 cmdlet은 [system.object](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) 를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-212">The cmdlet should call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="df7dd-213">@No__t-2 매개 변수가 모두 제공 되기 때문에 cmdlet이 동일한 코드에서 System.object를 호출 하는 것과 동일한 코드에서 [system.object](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) 를 호출 하는 것은 필요 하지 [않습니다.](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) 정보 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-213">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="df7dd-214">시간이 오래 걸리는 작업의 WriteProgress 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-214">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="df7dd-215">완료 하는 데 시간이 오래 걸리고 백그라운드에서 실행할 수 없는 Cmdlet 작업은 [system.object](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) 를 주기적으로 호출 하 여 진행률 보고를 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-215">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="df7dd-216">호스트 인터페이스 사용</span><span class="sxs-lookup"><span data-stu-id="df7dd-216">Use the Host Interfaces</span></span>

<span data-ttu-id="df7dd-217">경우에 따라 cmdlet은 사용자와 직접 통신 해야 하며,이는 여러 가지 Write 또는 [system.object](/dotnet/api/System.Management.Automation.Cmdlet) 가 지 원하는 메서드를 사용 하는 대신 사용자와 직접 통신 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-217">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="df7dd-218">이 경우 cmdlet은 [PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) 클래스에서 파생 되 고 [PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) 속성을 사용 해야 합니다 (예를 들어).</span><span class="sxs-lookup"><span data-stu-id="df7dd-218">In this case, the cmdlet should derive from the [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="df7dd-219">이 속성은 PromptForChoice, Prompt 및 WriteLine/ReadLine 유형을 포함 하 여 서로 다른 수준의 통신 유형을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-219">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="df7dd-220">또한 가장 구체적인 수준에서 개별 키를 읽고 쓰고 버퍼를 처리 하는 방법도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-220">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="df7dd-221">Cmdlet이 GUI (그래픽 사용자 인터페이스)를 생성 하도록 특별히 디자인 되지 않은 경우 [PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) 속성을 사용 하 여 호스트를 우회 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-221">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="df7dd-222">GUI를 생성 하도록 설계 된 cmdlet의 예는 [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-222">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="df7dd-223">Cmdlet은 [System.web](/dotnet/api/System.Console) API를 사용 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-223">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="df7dd-224">Cmdlet 도움말 파일 만들기 (SD05)</span><span class="sxs-lookup"><span data-stu-id="df7dd-224">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="df7dd-225">각 cmdlet 어셈블리에 대해 cmdlet에 대 한 정보가 포함 된 Help .xml 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-225">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="df7dd-226">이 정보에는 cmdlet에 대 한 설명, cmdlet의 매개 변수에 대 한 설명, cmdlet의 사용 예 등이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-226">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="df7dd-227">코드 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-227">Code Guidelines</span></span>

<span data-ttu-id="df7dd-228">Cmdlet 및 기타 cmdlet을 사용 하는 것과 일관 된 사용자 환경을 보장 하기 위해 cmdlet을 코딩 하는 경우 다음 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-228">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="df7dd-229">사용자의 상황에 적용 되는 코드 지침을 찾았으면 유사한 지침에 대 한 디자인 지침을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-229">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="df7dd-230">매개 변수 코딩 (SC01)</span><span class="sxs-lookup"><span data-stu-id="df7dd-230">Coding Parameters (SC01)</span></span>

<span data-ttu-id="df7dd-231">**매개 변수** 특성을 사용 하 여 데코레이팅된 cmdlet 클래스의 public 속성을 선언 하 여 매개 변수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-231">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="df7dd-232">매개 변수는 cmdlet에 대해 파생 된 .NET Framework 클래스의 정적 멤버일 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-232">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="df7dd-233">**매개 변수** 특성을 선언 하는 방법에 대 한 자세한 내용은 [매개 변수 특성 선언](./parameter-attribute-declaration.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-233">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="df7dd-234">Windows PowerShell 경로 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-234">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="df7dd-235">Windows PowerShell 경로는 네임 스페이스에 대 한 액세스를 정규화 하는 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-235">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="df7dd-236">Cmdlet의 매개 변수에 Windows PowerShell 경로를 할당 하면 사용자는 특정 경로에 대 한 바로 가기 역할을 하는 사용자 지정 "드라이브"를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-236">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="df7dd-237">사용자가 이러한 드라이브를 지정 하는 경우 레지스트리의 데이터와 같은 저장 된 데이터를 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-237">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="df7dd-238">사용자가 cmdlet에서 파일 또는 데이터 원본을 지정할 수 있도록 허용 하는 경우 [system.string](/dotnet/api/System.String)형식의 매개 변수를 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-238">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="df7dd-239">둘 이상의 드라이브가 지원 되는 경우 형식은 배열 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-239">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="df7dd-240">매개 변수의 이름은-0 @no__t 이어야 하며 별칭은 `PSPath`입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-240">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span> <span data-ttu-id="df7dd-241">또한 `Path` 매개 변수는 와일드 카드 문자를 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-241">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="df7dd-242">와일드 카드 문자를 지원 하지 않아도 되는 경우 `LiteralPath` 매개 변수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-242">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="df7dd-243">Cmdlet에서 읽거나 쓰는 데이터를 파일로 사용 해야 하는 경우 cmdlet은 Windows PowerShell 경로 입력을 수락 해야 하며, cmdlet은 [Sessionstate](/dotnet/api/System.Management.Automation.SessionState.Path) 속성을 사용 하 여 windows powershell 경로를로 변환 해야 합니다. 파일 시스템에서 인식 하는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-243">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="df7dd-244">특정 메커니즘에는 다음과 같은 메서드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-244">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="df7dd-245">PSCmdlet. GetResolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="df7dd-245">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="df7dd-246">PSCmdlet. GetUnresolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="df7dd-246">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [<span data-ttu-id="df7dd-247">GetResolvedProviderPathFromPSPath (영문)</span><span class="sxs-lookup"><span data-stu-id="df7dd-247">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="df7dd-248">GetUnresolvedProviderPathFromPSPath (영문)</span><span class="sxs-lookup"><span data-stu-id="df7dd-248">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="df7dd-249">Cmdlet에서 읽기 또는 쓰기 데이터를 파일 대신 문자열 집합만 사용 하는 경우 cmdlet은 공급자 콘텐츠 정보 (`Content` 멤버)를 사용 하 여 읽고 써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-249">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="df7dd-250">이 정보는 [InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) 속성에서 가져온 것이 고,</span><span class="sxs-lookup"><span data-stu-id="df7dd-250">This information is obtained from the [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="df7dd-251">이러한 메커니즘을 통해 다른 데이터 저장소에서 데이터 읽기 및 쓰기에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-251">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="df7dd-252">와일드 카드 문자 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-252">Support Wildcard Characters</span></span>

<span data-ttu-id="df7dd-253">가능 하면 cmdlet은 와일드 카드 문자를 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-253">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="df7dd-254">Cmdlet의 여러 위치에서 와일드 카드 문자를 지원 합니다. 특히 매개 변수가 개체 집합에서 하나의 개체를 식별 하는 문자열을 사용 하는 경우에는 특히 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-254">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="df7dd-255">예를 들어 [Stopproc 자습서](./stopproc-tutorial.md) 의 샘플 **Stop proc** cmdlet은 프로세스 이름을 나타내는 문자열을 처리 하는 `Name` 매개 변수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-255">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="df7dd-256">이 매개 변수는 사용자가 중지할 프로세스를 쉽게 지정할 수 있도록 와일드 카드 문자를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-256">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="df7dd-257">와일드 카드 문자 지원을 사용할 수 있는 경우 일반적으로 cmdlet 작업에서 배열을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-257">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span> <span data-ttu-id="df7dd-258">경우에 따라 사용자가 한 번에 하나의 항목만 사용할 수 있기 때문에 배열을 지 원하는 것은 적절 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-258">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="df7dd-259">예를 들어, 사용자가 단일 위치만 설정 하므로 [집합 위치](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet은 배열을 지원할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-259">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="df7dd-260">이 인스턴스에서 cmdlet은 여전히 와일드 카드 문자를 지원 하지만 단일 위치에 대해 해상도를 강제 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-260">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="df7dd-261">와일드 카드 문자 패턴에 대 한 자세한 내용은 [Cmdlet 매개 변수에서 와일드 카드 문자 지원](./supporting-wildcard-characters-in-cmdlet-parameters.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="df7dd-261">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="df7dd-262">개체 정의</span><span class="sxs-lookup"><span data-stu-id="df7dd-262">Defining Objects</span></span>

<span data-ttu-id="df7dd-263">이 섹션에는 cmdlet에 대 한 개체를 정의 하 고 기존 개체를 확장 하기 위한 지침이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-263">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="df7dd-264">표준 멤버 정의</span><span class="sxs-lookup"><span data-stu-id="df7dd-264">Define Standard Members</span></span>

<span data-ttu-id="df7dd-265">표준 멤버를 정의 하 여 사용자 지정 types.ps1xml 파일의 개체 형식을 확장 합니다. types.ps1xml 파일을 템플릿으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-265">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="df7dd-266">표준 멤버는 이름이 PSStandardMembers 인 노드에 의해 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-266">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="df7dd-267">이러한 정의를 통해 다른 cmdlet 및 Windows PowerShell 런타임은 일관 된 방식으로 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-267">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="df7dd-268">매개 변수로 사용할 ObjectMembers 정의</span><span class="sxs-lookup"><span data-stu-id="df7dd-268">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="df7dd-269">Cmdlet에 대 한 개체를 디자인 하는 경우 해당 멤버가 해당 멤버를 사용 하는 cmdlet의 매개 변수에 직접 매핑되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-269">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="df7dd-270">이 매핑을 사용 하면 개체를 파이프라인으로 쉽게 보내고 하나의 cmdlet에서 다른 cmdlet으로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-270">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="df7dd-271">Cmdlet에서 반환 되는 기존 .NET Framework 개체에는 스크립트 개발자 또는 사용자에 게 필요한 몇 가지 중요 한 멤버나 편리한 멤버가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-271">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="df7dd-272">이러한 누락 된 멤버는 개체를 파이프라인으로 올바르게 전달할 수 있도록 올바른 멤버 이름을 표시 하 고 만드는 데 특히 중요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-272">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="df7dd-273">사용자 지정 types.ps1xml 파일을 만들어 이러한 필수 멤버를 문서화 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-273">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="df7dd-274">이 파일을 만들 때 *< Your_Product_Name >* 명명 규칙을 따르는 것이 좋습니다. Types.ps1xml.</span><span class="sxs-lookup"><span data-stu-id="df7dd-274">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="df7dd-275">예를 들어 `Mode` 스크립트 속성을 [system.object](/dotnet/api/System.IO.FileInfo) 형식에 추가 하 여 파일의 특성을 보다 명확 하 게 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-275">For example, you could add a `Mode` script property to the [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="df7dd-276">또한 `Count` 별칭 속성을 [system.string 형식에](/dotnet/api/System.Array) 추가 하 여 해당 속성 이름을 일관 되 게 사용할 수 있습니다 (`Length` 대신).</span><span class="sxs-lookup"><span data-stu-id="df7dd-276">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="df7dd-277">IComparable 인터페이스 구현</span><span class="sxs-lookup"><span data-stu-id="df7dd-277">Implement the IComparable Interface</span></span>

<span data-ttu-id="df7dd-278">모든 출력 개체에 대해 [system.object](/dotnet/api/System.IComparable) 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-278">Implement a [System.IComparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span> <span data-ttu-id="df7dd-279">이렇게 하면 출력 개체를 다양 한 정렬 및 분석 cmdlet으로 쉽게 파이프 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-279">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="df7dd-280">표시 정보 업데이트</span><span class="sxs-lookup"><span data-stu-id="df7dd-280">Update Display Information</span></span>

<span data-ttu-id="df7dd-281">개체에 대 한 디스플레이에서 예상 된 결과를 제공 하지 않는 경우 사용자 지정 *\<>의 productname*을 만듭니다. 해당 개체에 대 한 types.ps1xml 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-281">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="df7dd-282">잘 정의 된 파이프라인 입력 지원 (SC02)</span><span class="sxs-lookup"><span data-stu-id="df7dd-282">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="df7dd-283">파이프라인 중간에 대해를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-283">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="df7dd-284">파이프라인 중간에서 호출 될 것으로 가정 하는 cmdlet을 구현 합니다. 즉, 다른 cmdlet은 해당 입력을 생성 하거나 해당 출력을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-284">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="df7dd-285">예를 들어 `Get-Process` cmdlet은 데이터를 생성 하기 때문에 파이프라인의 첫 번째 cmdlet 으로만 사용 된다고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-285">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span> <span data-ttu-id="df7dd-286">그러나이 cmdlet은 파이프라인 중간에 맞게 설계 되었으므로이 cmdlet은 파이프라인의 이전 cmdlet 또는 데이터에서 검색할 프로세스를 지정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-286">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="df7dd-287">파이프라인의 입력 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-287">Support Input from the Pipeline</span></span>

<span data-ttu-id="df7dd-288">Cmdlet에 대해 설정 된 각 매개 변수에서 파이프라인의 입력을 지 원하는 매개 변수를 하나 이상 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-288">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="df7dd-289">파이프라인 입력 지원을 통해 사용자는 데이터 나 개체를 검색 하 고, 올바른 매개 변수 집합으로 전송 하 고, 결과를 cmdlet에 직접 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-289">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="df7dd-290">매개 **변수** 특성에 `ValueFromPipeline` 키워드, `ValueFromPipelineByPropertyName` 키워드 특성 또는 선언에 두 키워드가 모두 포함 된 경우 매개 변수는 파이프라인의 입력을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-290">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its  declaration.</span></span> <span data-ttu-id="df7dd-291">매개 변수 집합에 `ValueFromPipeline` 또는 `ValueFromPipelineByPropertyName` 키워드를 지 원하는 매개 변수가 없는 경우 cmdlet은 파이프라인 입력을 무시 하기 때문에 다른 cmdlet 뒤에 의미를 적용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-291">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="df7dd-292">ProcessRecord 메서드 지원</span><span class="sxs-lookup"><span data-stu-id="df7dd-292">Support the ProcessRecord Method</span></span>

<span data-ttu-id="df7dd-293">파이프라인에서 위의 cmdlet의 모든 레코드를 수락 하려면 cmdlet이 [ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-293">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="df7dd-294">Windows PowerShell은 cmdlet에 전송 된 모든 레코드에 대해이 메서드를 여러 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-294">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="df7dd-295">파이프라인에 단일 레코드 쓰기 (SC03)</span><span class="sxs-lookup"><span data-stu-id="df7dd-295">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="df7dd-296">Cmdlet에서 개체를 반환 하는 경우 cmdlet은 생성 되는 즉시 개체를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-296">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="df7dd-297">이 cmdlet은 결합 된 배열로 버퍼링 하기 위해 해당 변수를 포함 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-297">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="df7dd-298">그러면 개체를 입력으로 수신 하는 cmdlet이 출력 개체를 지연 없이 처리, 표시 또는 처리 하 고 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-298">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="df7dd-299">한 번에 하나씩 출력 개체를 생성 하는 cmdlet은 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-299">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="df7dd-300">출력 개체를 일괄 처리로 생성 하는 cmdlet (예: 기본 API가 출력 개체의 배열을 반환 하는 경우)은 두 번째 매개 변수를 `true`로 설정 하 여 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-300">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="df7dd-301">Cmdlet에서 대/소문자를 구분 하지 않고 대/소문자를 유지 합니다 (SC04).</span><span class="sxs-lookup"><span data-stu-id="df7dd-301">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="df7dd-302">기본적으로 Windows PowerShell 자체는 대/소문자를 구분 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-302">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="df7dd-303">그러나 많은 기존 시스템을 처리 하기 때문에 Windows PowerShell은 작업 및 호환성을 위해 대/소문자를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-303">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span> <span data-ttu-id="df7dd-304">즉, 문자를 대문자로 제공 하는 경우 Windows PowerShell은 해당 문자를 대문자로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-304">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="df7dd-305">시스템이 제대로 작동 하려면 cmdlet이이 규칙을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-305">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="df7dd-306">가능 하면 대/소문자를 구분 하지 않는 방식으로 작동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-306">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="df7dd-307">그러나 나중에 명령이 나 파이프라인에서 발생 하는 cmdlet에 대 한 원래 사례를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="df7dd-307">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="df7dd-308">참고 항목</span><span class="sxs-lookup"><span data-stu-id="df7dd-308">See Also</span></span>

[<span data-ttu-id="df7dd-309">필수 개발 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-309">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="df7dd-310">자문 개발 지침</span><span class="sxs-lookup"><span data-stu-id="df7dd-310">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

<span data-ttu-id="df7dd-311">[Writing a Windows PowerShell Cmdlet](./writing-a-windows-powershell-cmdlet.md)(Windows PowerShell Cmdlet 작성)</span><span class="sxs-lookup"><span data-stu-id="df7dd-311">[Writing a Windows PowerShell Cmdlet](./writing-a-windows-powershell-cmdlet.md)</span></span>
